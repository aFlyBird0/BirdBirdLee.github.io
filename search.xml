<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Scrapy知网爬虫（一）整体理论篇</title>
    <url>/2021/07/Scrapy%E7%9F%A5%E7%BD%91%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89%E6%95%B4%E4%BD%93%E7%90%86%E8%AE%BA%E7%AF%87/</url>
    <content><![CDATA[<p>简要介绍：本系列是基于scrapy开发的知网爬虫（专利、论文、项目），已经爬了百万级别的数据，程序健壮性、速度均得到了验证。采用模块化的设计，拥有流程控制模块、错误重爬模块、任务分发模块，任务监督模块等。该系列预计分为：理论篇（整体介绍）、详细设计篇（披露代码细节，完整代码不一定开源）等。本文为理论篇，整体介绍了爬虫的理念、概要设计。本文由原word论文直接导出而后简单修改，所以部分样式可能没有md原汁原味。</p>
<span id="more"></span>

<h1 id="1-相关概念、理论和工具介绍"><a href="#1-相关概念、理论和工具介绍" class="headerlink" title="1 相关概念、理论和工具介绍"></a>1 相关概念、理论和工具介绍</h1><h2 id="1-1-Scrapy"><a href="#1-1-Scrapy" class="headerlink" title="1.1 Scrapy"></a>1.1 Scrapy</h2><p>Scrapy是一套基于Twisted的异步处理框架，由纯Python实现，用于从web网站中抓取结构化数据，是目前应用最广泛的工业级爬虫框架。Scrapy最大的优势在于，它设计了一个爬虫的通用架构，预设了多种爬虫基类，也提供了许多组件和中间件，任何人都能按照自己的需求快速写出高性能爬虫代码，并根据自己的需要编写中间件灵活应对各种业务场景。</p>
<p>Scrapy框架主要由七大组件组成，它们分别是Scrapy引擎(Scrapy Engine)、调度器(Scheduler)、下载器(Downloader)、爬虫（Spider）、实体管道(Item Pipeline)、下载器中间件(Downloader middlewares)和爬虫中间件(Spider middlewares)。展示了Scrapy的整体架构。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/d98d59fc3e58e6364ae032e43ab0851d.png" alt="图1-1 Scrapy 整体架构"></p>
<center>图1-1 Scrapy 整体架构</center>

<h3 id="1-1-1-Scrapy引擎-Scrapy-Engine"><a href="#1-1-1-Scrapy引擎-Scrapy-Engine" class="headerlink" title="1.1.1 Scrapy引擎(Scrapy Engine)"></a>1.1.1 Scrapy引擎(Scrapy Engine)</h3><p>引擎是Scrapy框架的核心，用来控制调度器、下载器、爬虫。引擎相当于爬虫的“大脑”，操控数据在系统中所有组件的传送，并在合适的时机触发相应的动作。</p>
<h3 id="1-1-2-调度器-Scheduler"><a href="#1-1-2-调度器-Scheduler" class="headerlink" title="1.1.2 调度器(Scheduler)"></a>1.1.2 调度器(Scheduler)</h3><p>在Scrapy中，所有的request（网络请求）都交由调度器统一管理。无论是start_url（起始请求）还是后续在页面中获取的新的url，都经由引擎传送至调度器，然后入队，统一调度，待轮到请求发起时，调度器将队列中的request出队，提供给引擎，传送至其他模块。</p>
<p>调度器的设置，能更加高效利用CPU从而提高运行效率。没有队列作缓冲，网络延迟、文件读取等情况都会阻塞进程的运行，而将request放在调度器中，可以由引擎决定程序执行、网络请求、文件读取的时机，三大任务并行执行不会相互阻塞。</p>
<p>同时调度器带有自动request去重功能，对于每一种请求，都可选择是否去重。值得一提的是，调度队列保存在内存中，若程序异常终止，缓存的request会丢失。</p>
<h3 id="1-1-3-下载器-Downloader"><a href="#1-1-3-下载器-Downloader" class="headerlink" title="1.1.3 下载器(Downloader)"></a>1.1.3 下载器(Downloader)</h3><p>下载器用于执行网络请求，高速下载网络上的资源。Scrapy建立在异步模型<a href="https://www.oschina.net/p/twisted+matrix">Twisted</a>之上，Twisted采用回调机制，在处理IO或执行网络请求等费时操作时，程序不会一直等待响应，而是会注册一个回调至事件循环中并为该事件分配一个回调后处理的函数，而后将处理器资源分配到其他任务中，在多个任务快速切换且不用担心阻塞和线程安全问题。所以用户在编写代码时，只需要用少量的代码，即可编写出高效率的线程安全爬虫。</p>
<h3 id="1-1-4-爬虫（Spider）"><a href="#1-1-4-爬虫（Spider）" class="headerlink" title="1.1.4 爬虫（Spider）"></a>1.1.4 爬虫（Spider）</h3><p>爬虫，是用户需要自定义最多的部分，涉及初始请求的构造、网页结构的解析、实体结构的提取、新请求的生成等。</p>
<ul>
<li><p>初始请求构造：用户传入start_urls列表作为初始请求url，Scrapy提取初始Url，调用默认的start_requests函数将url封装成request，传至网络请求调度器。业务场景复杂时，当简单的url列表难以满足爬虫需要（如需要一次传入不同的参数作为起始url），也可直接覆写<br>start_requests函数，自行封装requests传入调度器</p>
</li>
<li><p>网页结构解析：Request得到的是html源代码，需要再使用网页解析工具，如Xpath（XML<br>Path Language）、Beautiful<br>Soup。前者提供了非常简洁明了的路径选择表达式用于从XML文档中提取信息，后者封装了简单的Python式函数用来处理XML、HTML文档的标签提取、搜索。前者的优势在于速度快，灵活高效，后者的优势在于使用简单，本设计选用了Xpath解析网页。</p>
</li>
<li><p>实体结构的提取：解析网页结构完毕后，爬虫真正的目的是数据的持久化，所以用户需要将获取的一个个字段封装成不同类型的实体（Item），传至实体管道(Item<br>Pipeline)。</p>
</li>
<li><p>新请求的生成：一般情况下，初始url不会包含所有待爬url，程序编写者需自行实现链接提取、翻页等逻辑，以构建新的网络请求。在本设计中，设定每一轮次获取特定日期特定学科分类的所有文献信息。实际运行时，start_requests只执行一次搜索请求，之后通过翻页与链接提取获得所有文献链接，再将链接加入请求调度序列执行新一轮请求解析。</p>
</li>
</ul>
<h3 id="1-1-5-实体管道-Item-Pipeline"><a href="#1-1-5-实体管道-Item-Pipeline" class="headerlink" title="1.1.5 实体管道(Item Pipeline)"></a>1.1.5 实体管道(Item Pipeline)</h3><p>用户在Sider中提取出实体结构（Item），将被发送至实体管道，经过用户定义的process_item函数后，持久化至数据库或本地文件，也可丢弃。</p>
<h3 id="1-1-6-下载器中间件-Downloader-middlewares"><a href="#1-1-6-下载器中间件-Downloader-middlewares" class="headerlink" title="1.1.6 下载器中间件(Downloader middlewares)"></a>1.1.6 下载器中间件(Downloader middlewares)</h3><p>下载器中间件是在引擎及下载器之间的hook（钩子），下载器返回的response先经过中间件处理后再交由引擎。通过下载器中间件的创建，重写其中的方法，可扩展Scrapy功能，实现更换请求头、设置代理、自动重试、网络异常处理等功能。</p>
<h3 id="1-1-7-爬虫中间件-Spider-middlewares"><a href="#1-1-7-爬虫中间件-Spider-middlewares" class="headerlink" title="1.1.7 爬虫中间件(Spider middlewares)"></a>1.1.7 爬虫中间件(Spider middlewares)</h3><p>Spider中间件是在引擎及爬虫之间的钩子，可以过滤引擎传递的响应（response）和数据（items）。</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="2-科技大数据采集处理系统"><a href="#2-科技大数据采集处理系统" class="headerlink" title="2 科技大数据采集处理系统"></a>2 科技大数据采集处理系统</h1><h2 id="2-1-爬虫概述"><a href="#2-1-爬虫概述" class="headerlink" title="2.1 爬虫概述"></a>2.1 爬虫概述</h2><p>科技大数据采集处理系统采用Scrapy-Redis框架，实现了全自动化抓取知网专利、论文并持久化至文件系统中。</p>
<p>本系统在数据完整性、爬虫速度、错误处理、程序健壮性与可维护性上都进行了深入的研究，代码量超过3000行。主要由流程控制模块、链接获取模块、Scrapy-Redis核心引擎、页面解析模块、错误记录与错误重爬模块组成。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/bfe072103482e3bba5e91d0c8fc3892d.png"></p>
<center>图2-1 知网爬虫整体流程图</center>

<h2 id="2-2-文献遍历策略分析"><a href="#2-2-文献遍历策略分析" class="headerlink" title="2.2 文献遍历策略分析"></a>2.2 文献遍历策略分析</h2><p>评价爬虫成功与否的一大标准就是数据量的完整度，因此，必须采取一种合理的能够便利整个专利库、论文库检索方案。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/aee90b91eca87e40fa4162bcb2ac3340.png"></p>
<center>图2-2 知网专利高级检索-界面示意</center>

<p>上图是知网专利的高级检索页面，经分析，程序可通过学科分类（左侧红框所示）与公开日（右侧红框所示）限定检索范围，实现整个数据库的遍历。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/07f30c260a9c53e147482e3178868028.png"></p>
<center>图2-3 知网专利高级检索-结果示意</center>

<p>如上图所示，知网搜索结果为每页50条，只返回前120。所以必须保证每一次检索的专利条数都在6000条以内，因此本设计采用了每轮只爬特定日期的特定学科分类下的文献，确保搜索结果不溢出。下图为文献遍历策略流程图。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/1317903ff48bb4b9cc36d8f5934e29ba.png"></p>
<center>图2-4 爬虫遍历策略</center>

<h2 id="2-3-流程控制模块"><a href="#2-3-流程控制模块" class="headerlink" title="2.3 流程控制模块"></a>2.3 流程控制模块</h2><h3 id="2-3-1-模块设计理念与优点"><a href="#2-3-1-模块设计理念与优点" class="headerlink" title="2.3.1 模块设计理念与优点"></a>2.3.1 模块设计理念与优点</h3><p>流程控制模块是上文文献遍历策略的具体实现。一个优秀的爬虫系统是无状态的，即爬虫本身不记录任何运行状态，一切交由外部数据库掌控。优点有三：</p>
<p>（1）爬虫任务的制定和代码无关，每次只需启动爬虫无需改动代码，通过修改数据库可在远程直接控制爬虫任务的开始、暂停。</p>
<p>（2）若状态管理在爬虫内部实现，由内存控制，那么当程序异常终止（如严重异常、进程被Kill）时，极易丢失当前任务进度</p>
<p>（3）本流程控制模块兼具简单的远程监控功能，可实时查看爬虫进度</p>
<p>通过流程控制模块，爬虫核心部分只需实现爬取特定日期特定学科分类下的所有文献功能即可，至于启动时该从哪里开始爬、爬完当前学科分类与日期下一个爬什么、异常终止再启动后从哪里续爬、爬虫任务设定与读取等功能，全部交由流程控制模块即可。（注意，本流程控制模块实现的是任务级的粗粒度状态管理，请求级别的细粒度状态管理将在后文展开介绍）。</p>
<h3 id="2-3-2-模块具体实现"><a href="#2-3-2-模块具体实现" class="headerlink" title="2.3.2 模块具体实现"></a>2.3.2 模块具体实现</h3><p>前文讲到，文献遍历的核心在于任务制定以及每次传给爬虫程序一个日期加一个学科分类信息，本模块将围绕其展开。分持久层与代码流程两部分讲解</p>
<h3 id="2-3-2-1-持久层"><a href="#2-3-2-1-持久层" class="headerlink" title="2.3.2.1 持久层"></a>2.3.2.1 持久层</h3><p>持久层，即采用什么数据库持久化爬虫任务状态，又如何定义数据库结构</p>
<p><strong>数据库选用：</strong></p>
<p>程序原先采用的是文件系统置访问标记的方式，但这样的弊端太多：访问标记需要全局统一、每次获取下一个日期和分类需要重新遍历整个文件、线程不安全，因为同时涉及日期和分类两个状态的更新导致文件修改逻辑非常复杂，不但要置访问标记还要在遍历完一个轮次后擦除访问标记。</p>
<p>后期系统采用Mysql数据库，优点如下：</p>
<p>（1）对状态的修改直接调用数据库的增删改查即可，方便且不易出错</p>
<p>（2）可远程控制任务开始、停止</p>
<p>（3）线程安全</p>
<p><strong>数据库结构定义：</strong></p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/1f2cafb84ef623134db9340aef956984.png"></p>
<center>图 2-5 Status 爬虫任务状态表结构定义</center>

<p>本系统包含了专利、论文、成果等多种文献爬虫，所以设置了type字段用于区分。curCode字段包含两个含义，起始日期与当前日期，程序启动时爬虫将读取该字段作为起始日期，启动后将不断更新该字段来表示当前运行日期。endDate字段为终止日期，由用户设定，也可不设定，默认为当天。Status<br>字段简单指示了爬虫的状态，流程控制模块每次被调用的时候会将当前时间更新至status，用户可根据该字段判断程序是否正在运行。</p>
<h3 id="2-3-2-2-代码流程"><a href="#2-3-2-2-代码流程" class="headerlink" title="2.3.2.2 代码流程"></a>2.3.2.2 代码流程</h3><p>本采集系统将所有学科分类代码放在了一个文件中，在启动时读取一次加载至内存中，得到学科分类列表。因为列表固定不变，所以无需存放至数据库中。程序运行时，通过比对内存中的学科分类列表和从数据库中获取的上一次爬的学科分类即可获得上一次学科分类的下标，进而通过下标加一的操作获得下一个学科分类。下图是完整的学科分类与日期获取控制流程。本流程图隐去了数据库重连，任务有效性判断（如未定义起始日期）等细节。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/80e468db53d9d06a95f382465f78c6cf.png"></p>
<center>图2-6 爬虫任务流程控制模块-流程图</center>

<h3 id="2-3-3-模块使用"><a href="#2-3-3-模块使用" class="headerlink" title="2.3.3 模块使用"></a>2.3.3 模块使用</h3><p>任务设定：程序运行前设定开始日期(curDate)、结束日期(endDate,结束日期可不设，默认当天），运行程序即可。可在运行中任意时刻更新结束日期字段</p>
<p>任务状态查看：通过curDate和curCode字段可查看当前运行进度，通过status字段查看上一次调用流程控制模块时间判断程序是否仍在运行中。</p>
<p>任务终止：更新结束日期字段，使其早于（小于）开始日期(curDate)字段即可。程序会在处理完当前队列中缓存的请求、保存完所有管道中的文件后停止。</p>
<h2 id="2-4-链接获取模块"><a href="#2-4-链接获取模块" class="headerlink" title="2.4 链接获取模块"></a>2.4 链接获取模块</h2><p>链接获取模块负责获取一个分类下所有的文献链接，对于每个链接发起新的页面请求，以获得文献标题、摘要等信息。新的请求将由引擎通过请求队列统一调度。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/6c84b51a3c61ea097e3ee5eab1e42b3b.png"></p>
<center>图2-7 链接获取模块流程图</center>

<p>流程图见上，展示了程序如何获取特定日期特定学科分类下的所有链接，涉及链接提取解析、自动翻页、Cookie更换等。Cookie更换是因为知网限定每次搜索，只能翻15页左右，所以在翻页到达一定次数的时候，需要重新执行搜索请求更换Cookie。程序的结束由流程控制模块决定，故本流程图未标明。</p>
<h2 id="2-5-页面解析模块"><a href="#2-5-页面解析模块" class="headerlink" title="2.5 页面解析模块"></a>2.5 页面解析模块</h2><p>页面解析模块负责解析下载器返回的网页内容，提取结构化信息，生成文献对象，传至数据管道。</p>
<p>系统采用xpath作为网页结构解析工具，因代码细节过多，本文只介绍专利内容解析中较为复杂的一个例子。专利详情页（部分）如下图：</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/ccb50cfa763a8226fc6dfa223580fab6.png"></p>
<center>图2-8 专利详情页</center>

<p>初次尝试链接提取时，程序按顺序提取了右侧的非加粗文字。后期随着程序的运行，出现了下标越界等异常，问题在于：专利页面字段不是固定的，如部分专利拥有“代理人”字段，没有“申请公布号”、“公开公告日”，而是“授权公告日”、“公开公告日”等。</p>
<p>故本系统采用了如下方式，确保能成功提取到所有字段：将形如“专利类型：发明公开”的字段作为一个整体一起提取，将其看作键值的形式，通过分析大量的专利页面找到所有的键，之后将当前页面的键与键列表一一比对，解决了字段不一的问题。实际运行过程中，还发现，“申请公布号”和“公开公告日”两字段前有个空格。</p>
<p>下面是网页代码分析。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/a487da26cf52afe46d36579748e1acc0.png"></p>
<center>图 2-9 专利详情-网页源代码</center>

<p>网页源代码部分也较为混乱，表面上获取row、rowtit、funds等标签即可，仔细分析网页结构将会发现，网页同时含有row,row-1, row-2, rowtit,<br>rowtit2等标签，并且不同字段间的网页标签选择并没有明显规则。加上含有超链接文字与纯文本的提取又不同，给网页解析带来了非常大的困难。</p>
<p>所以系统选用了灵活性极高的xpath，用少量的代码优雅解决了这一问题，下图代码同时展示了对复杂标签的提取策略与前文提高的键值方式解析字段的详细实现方法。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/b778a209fdc8582efdc7d98051fbb08c.png"></p>
<center>图2-10 专利网页内容解析代码</center>

<h2 id="2-6-下载中间件设置"><a href="#2-6-下载中间件设置" class="headerlink" title="2.6 下载中间件设置"></a>2.6 下载中间件设置</h2><p>本系统改写了下载中间件，主要做了两项工作：</p>
<p>（1）在引擎从调度序列取出request后，设置了请求头信息，如修改user-agent，动态设置代理</p>
<p>（1）网页请求结果预分析，遇到异常网络状态码时，自动重试，达到一定次数后发送信息至错误记录模块。</p>
<h3 id="2-6-1-请求头设置"><a href="#2-6-1-请求头设置" class="headerlink" title="2.6.1 请求头设置"></a>2.6.1 请求头设置</h3><p>（1）在项目设置文件中设置默认请求头，如下：</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/b8a121a0ad0c294f96a3827a0ceb9cc0.png"></p>
<center>图2-11 默认请求头</center>

<p>(2)预定义多个user-agent，重写下载中间件的process_request方法，每次随机选取一个user-agent</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/3355c7a31c7557903a1ba4f756264739.png"></p>
<center>图 2-12 user-agent设置</center>

<p>（3）Referer是反爬虫手段之一，告知服务器在此请求发送前用户访问的是哪个链接，为了防止被网站识别，这里需要针对专利和论文设置不同的Refer，值为高级搜索页面链接，同样写在process_request中。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/c4fc7a36fff4fa2cada745a3a6d978c1.png"></p>
<center>图 2-13 referer设置</center>

<h3 id="2-6-2-代理设置"><a href="#2-6-2-代理设置" class="headerlink" title="2.6.2 代理设置"></a>2.6.2 代理设置</h3><p>为了防止因反爬机制高频率抓取网页内容而被封禁ip，可以采用代理，起到伪装自己而不被服务器发现真正请求源的作用。Scrapy的代理设置方式与请求头设置方式类似，新建下载中间件类，重写process_request方法，修改请求头添加相应字段即可。由于不同代理商的具体获取方式不同，本文略过代理获取、使用部分，主要介绍本设计研发的适用于Scrapy框架的两种代理设置通用工具。</p>
<p><strong>全局代理开关设置</strong></p>
<p>爬虫初期需要快速抓取数据需要代理，后期增量更新时抓取量少可不用代理，所以非常有必要设计一套简单可行的全局代理开关设置方法。</p>
<p>本设计采用的方式是在scrapy设置文件settings.py中增设PROXY_OPEN设置项，所有使用代理的地方通过判断该设置值选择是否启用代理。</p>
<p>但代理中间件的开启与否相对复杂，使用了python的类三目运算，动态设置代理中间件的优先级变量，若PROXY_OPEN为True则设定数字优先级，此时代理中间件开启，否则设定优先级为None，即不开启。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/819037d8136e088a1ed18cc61cdad30c.png"></p>
<center>图 2-14 代理中间件开关设置</center>

<p><strong>代理复用组件</strong></p>
<p>网络代理费用较为昂贵，以本次研究使用的代理为例，包月500元左右，ip不限量，但只能每5秒获取5个代理IP，所以本设计设计了一套代理复用组件。可在配置文件中设置平均代理复用的次数，组件将每次随机返回一个代理，并记录总使用次数，若发生代理失效异常，组件也会自动将失效代理剔除，所有代理复用完毕后将自动获取下一批代理，流程图如下（省略了异常处理等细节）：</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/cf009475b78a7364cf27fe50dced079b.png"></p>
<center>图2-15 代理复用组件流程图</center>

<h3 id="2-6-3-网络异常处理"><a href="#2-6-3-网络异常处理" class="headerlink" title="2.6.3 网络异常处理"></a>2.6.3 网络异常处理</h3><p>数据采集时，经常会遇到各种网络异常，造成的原因是多样的，如：当前电脑网络拥堵、服务器错误、请求过快被服务器识别、302跳转、验证码弹窗、Cookie失效。其中的大部分异常只是由于暂时性的网络不畅或部分tcp连接丢失造成的，这部分网络错误重新请求是可以正常获取网页内容的。</p>
<p>所以本设计网络异常处理分为两步：</p>
<ol>
<li><p>通过改写下载中间件获取异常网络状态码，若该状态码在定义的重试状态码列表内，立即重试，否则抛弃该请求，交由错误记录模块处理。</p>
</li>
<li><p>定义最大重试次数，超过后有可能是Cookie失效等原因导致目前多次请求无法正常获取内容，交由错误记录模块处理。</p>
<p>具体代码如下：</p>
</li>
</ol>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/fc38caa5aa289ce4236f99d30cc28a53.png"></p>
<center>图2-16 网络异常处理代码</center>

<p>代码除了执行自动重试操作，还进行了有关代理异常的判断，如果异常是由于代理引起的，则会向代理模块发送代理错误信息，移除失效代理。其中的save_url函数逻辑较简单未贴出：判断当前重试次数是否超过最大重试次数，若超过，调用错误记录函数记录出错日期、学科分类、链接。</p>
<h2 id="2-7-异常处理、错误记录与错误重爬模块"><a href="#2-7-异常处理、错误记录与错误重爬模块" class="headerlink" title="2.7 异常处理、错误记录与错误重爬模块"></a>2.7 异常处理、错误记录与错误重爬模块</h2><h3 id="2-7-1-异常处理"><a href="#2-7-1-异常处理" class="headerlink" title="2.7.1 异常处理"></a>2.7.1 异常处理</h3><p>为了保证程序的健壮性，必须在程序异常时由下至上、由细及粗地接住所有可能的异常、错误。底层先接住可知的、已预测到的、主动抛出的异常，如有时请求网页传回的是js而非html，抛出网页解析异常，这部分异常不记录具体异常信息，只记录出错的日期、学科分类、链接；对于未预测到的异常，顶层定义一个全局异常处理类，记录详细异常调用栈，并记录出错日期、学科分类、链接。</p>
<h3 id="2-7-2-错误记录"><a href="#2-7-2-错误记录" class="headerlink" title="2.7.2 错误记录"></a>2.7.2 错误记录</h3><p>为了保证数据的完整性，对出错任务的记录与重爬尤为重要。</p>
<p>记录的错误类型：本数据采集系统主要分两步，第一步是获取文献链接，第二步是请求文献链接解析内容。因此，错误记录也被分为两种，一种是在获取文献链接阶段时，记录失败任务对应的日期、学科分类；另一种则是在请求文献链接得到文献详细信息时，记录出错失败的链接。</p>
<p>错误捕捉策略：随着程序的不断迭代优化，因对网页结构分析不到位与程序代码缺陷引发的异常已被全部规避。目前部分链接获取与解析失败的原因绝大多数还是源于网络问题，如非正常网络状态码（302跳转、服务器拒绝连接、请求超时），这部分会由网络异常处理模块捕捉，传送至错误记录模块；另一部分则是程序在实际运行中，存在少量状态码正确但网页内容不是预期搜索结果的情况，这部分也会被错误记录模块记录下来。</p>
<p>错误记录数据表结构：程序共定义了两个数据表用来记录错误，errorCode表用于记录链接获取阶段时的失败任务；errorLink用于记录请求文献链接解析详情时的失败链接。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/80a585d0c15f4c231391a2bcff3982dc.png"></p>
<center>图2-17 errorCode表</center>

<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/900ed8305b80ebcced5006aadc67445a.png"></p>
<center>图2-18 errorLink表</center>

<h3 id="2-7-3-错误重爬模块"><a href="#2-7-3-错误重爬模块" class="headerlink" title="2.7.3 错误重爬模块"></a>2.7.3 错误重爬模块</h3><p>系统会在运行时自动记录两种错误至mysql数据库中，当所有预设任务结束时，程序将进入错误重爬模块。</p>
<p>第一步，读取errorCode表，获取失败的日期与学科分类，重新获取文献链接，并解析链接对应的文献详情，直到表空。因为爬虫核心实现了每轮次对特定日期特定日期分类的文献抓取工作，正常任务流程的日期与学科分类输入源来自流程控制模块，在错误重爬时，只需要更换输入源为errorCode表即可。</p>
<p>第二步：读取errorLink表，获取请求文献详情阶段失败的文献链接，重新执行请求与解析，直到表空。</p>
<h2 id="2-8-请求级细粒度爬虫状态管理"><a href="#2-8-请求级细粒度爬虫状态管理" class="headerlink" title="2.8 请求级细粒度爬虫状态管理"></a>2.8 请求级细粒度爬虫状态管理</h2><p>本数据采集系统的网络请求主要分为两个阶段，第一阶段获取所有的文献链接，第二阶段请求文献链接获取文献详情。为了最大程度实现系统运行的自动化，这两个阶段其实是互相交织、无中间文件生成、无明显顺序的。系统并不是先获取完所有的文献链接，存至文件中，结束后再启动第二阶段工作，而是每请求得到一个链接，立即传送至第二阶段。</p>
<p>前文的流程控制系统中对状态管理只是停留在任务级，或者说只能实现记录当前爬到哪个“日期-学科分类”轮次。但要想完美解决细粒度状态记录、防止数据丢失、文献去重还有非常多的问题要解决，主要有以下几点：</p>
<ol>
<li><p> Scrapy调度器管理的请求队列保留在内存中，程序异常终止时，所有未调度请求会丢失。待调度的请求包括第一阶段链接获取与第二阶段内容解析。</p>
</li>
<li><p> 因Scrapy的统一调度策略，致使当前轮次并不与调度队列中的请求同步，调度队列中可能还存放着前几轮获取的文献链接，待传送至第二阶段的获取文献详情模块。这使得程序中断重启动后很难决定从哪个轮次继续：如果只是重复上一未完成轮次可能会漏掉前几轮次的未传入第二阶段的链接，如果重复轮次过深又会多做大量不必要的重复性链接获取工作。</p>
</li>
<li><p> Scrapy自带去重器也在内存中，所以只能保证单次运行抓取不重复，若程序意外中断而重启，重新抓取时该去重器无法达到去重效果。</p>
</li>
</ol>
<p>系统采用了Scrapy-Redis框架解决上述问题，具体如下：</p>
<ol>
<li><p> 使用Redis持久化请求队列，将原本内存中处理的调度换成Redis队列。</p>
</li>
<li><p> 使用Redis进行去重，为每个需要去重的请求生成一个独特的指纹，持久化至Redis中（Set数据结构），新请求加入请求队列前，先判断数据库中是否含有相同指纹，无则入队。</p>
</li>
</ol>
<p>使用Redis持久化调度器中的请求队列，使得每个新生成的请求都会被立刻缓存至Redis中，程序终止时几乎不会丢失；程序重新启动后，将从Redis读取请求，完美解决问题（1）（2）。</p>
<p>使用Redis将去重数据持久化，程序运行而去重序列不丢失，解决了问题（3）。</p>
<h2 id="2-9-任务分发"><a href="#2-9-任务分发" class="headerlink" title="2.9 任务分发"></a>2.9 任务分发</h2><p>为了进一步加快抓取速度，本设计构建了任务分发模式，是分布式爬虫的一种实现方式。</p>
<p>传统的分布式爬虫是多个服务器上运行一个任务，这样的形式优点在于可以快速执行完一个任务。但程序的运行环境安装非常繁琐，可行的方案是使用docker统一安装，但linux服务器数量不多，window安装docker也很麻烦。</p>
<p>故本设计将程序使用了pyinstaller打包工具，将代码和运行环境一同打包成可执行文件，可在任意一台联网的windows系统电脑上运行，大幅度增强了程序的移植性，提高了分发效率。</p>
<p>得益于系统采用的任务状态管理模块，使得任务的切分非常方便。原系统任务的设定通过操作数据库完成，新系统只要加一个自动建库建表、从配置文件中读取任务、自动更新数据库任务的逻辑即可。</p>
<p>本分发模式的优点在于：</p>
<ol>
<li> 运行环境依赖低，可以直接使用家用电脑运行程序</li>
<li> 程序与配置分离，一次打包后，通过修改配置文件就能实现任务的分发</li>
</ol>
<h1 id="3-Redis在Scrapy中的使用"><a href="#3-Redis在Scrapy中的使用" class="headerlink" title="3 Redis在Scrapy中的使用"></a>3 Redis在Scrapy中的使用</h1><h2 id="3-1-Scrapy介绍（只介绍redis相关部分）"><a href="#3-1-Scrapy介绍（只介绍redis相关部分）" class="headerlink" title="3.1 Scrapy介绍（只介绍redis相关部分）"></a>3.1 Scrapy介绍（只介绍redis相关部分）</h2><ul>
<li>请求调度方面<ul>
<li>平时我们写爬虫，使用requests，请求后处理结果都是顺序执行的</li>
<li>scrapy是基于twisted的，所有的请求都对应了一个回调函数</li>
<li>并且，scrapy的所有请求不是马上执行的，它有个调度器，所有的网络请求都会被统一存在一个队列里面，由scrapy引擎调度</li>
<li>问题在于，这个 <strong>调度序列在内存里面</strong> ，程序终止的时候，调度队列会丢失</li>
</ul>
</li>
<li>去重方面<ul>
<li>Scrapy有自带的去重器，同时它也在内存里面，所以它只能保证程序单次运行，链接不重复。但当你要爬的数据量大的时候，或者说想实现断点续爬功能，就gg了。</li>
</ul>
</li>
<li>scrapy提供的解决方式<ul>
<li>它自带一个jobdir功能，可以在程序终止的时候把内存中的状态信息写到磁盘里。但我不太敢用，听有人说有时候不好用。加上业务逻辑复杂，我觉得还是自己写的靠谱。</li>
</ul>
</li>
<li>单机、集群（或者说分布式方面）<ul>
<li>无论是前面的<ul>
<li>①请求调度</li>
<li>②请求去重</li>
<li>③以及没提到的，我们获取了请求了网页，并且提取了其中的字段，将字段封装成了对象，将python对象执行数据处理与保存操作的时候</li>
</ul>
</li>
<li>这三个操作原始的scrapy都是单机的，用redis可以达到分布式的作用</li>
</ul>
</li>
</ul>
<h2 id="3-2-Scrapy-Redis框架"><a href="#3-2-Scrapy-Redis框架" class="headerlink" title="3.2 Scrapy-Redis框架"></a>3.2 Scrapy-Redis框架</h2><ul>
<li>持久化请求队列，保证数据几乎不丢失<ul>
<li>之前的scrapy策略是，有了新的请求，将请求入队至内存中的调度队列</li>
<li>现在的策略是，有了新请求，将请求放到redis中，出队了再删除</li>
<li>所以之前程序一关闭，就会丢失队列中所有的请求，数量级在几十到上千乃至上万；现在因为每个新请求直接是入了redis的队的，所以关闭了几乎不会丢失请求（要丢失的话可能只是某个函数执行到一半导致的请求丢失），丢失的数量基本是0，最多1、2这样</li>
<li>换一种表达方式就是，入队这个操作其实是很快的，但是原来只有出队了，保存了数据，这个请求对应的数据才算真正抓取到了，所以程序一关闭，没执行出队的请求、请求了没来得及处理、保存数据的，都会丢失；现在因为是把请求队列放在redis了，数据丢失只可能发生在将入队却未入队的那一刹那，几乎不会丢</li>
</ul>
</li>
<li>持久化items<ul>
<li>解释一下items：请求得到网页源代码，提供了你想要的字段，生成的数据对象（比如提取摘要、作者，封装成论文对象，论文就是items），得到数据对象之后，执行数据写入也有个间隙，持久化items可以起到防止这阶段的数据丢失的作用</li>
</ul>
</li>
<li>持久化去重队列<ul>
<li>之前讲到scrapy的去重在内存里，只能保证本机本次运行的链接不重复，那么如果持久化了，就能保证集群、多次运行链接不重复</li>
</ul>
</li>
<li>集群、分布式<ul>
<li>这个很好理解了，请求队列由redis掌管，那么可以由多个slave都从redis读请求，分布执行；去重也可；也可以把数据处理弄成分布式的，因为封装完成的items会先经过redis暂存一下。（不过我没用itmes的持久化，因为毕竟论文专利对象太占内存了。。）</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>细窥Golang类型系统</title>
    <url>/2021/12/%E7%BB%86%E7%AA%A5Golang%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文是一篇翻译，源于与好友的一次关于 Golang 底层类型判定的讨论。找到了这篇好文，奈何中文翻译欠佳（内容缺、词不达意），就看了原版。看完就忍不住翻译下来，<strong>逐字斟酌，并补充了许多内容</strong>，标示「译者注」。——by 爱飞的鸟</p>
<p>以下正文：</p>
<p><strong>副标题：配合示例详解 Go 语言类型系统</strong></p>
<p>我们先从一个基本问题开始吧！  </p>
<h2 id="为什么我们需要类型系统？"><a href="#为什么我们需要类型系统？" class="headerlink" title="为什么我们需要类型系统？"></a>为什么我们需要类型系统？</h2><p>在回答这个问题之前，我们先看看平日里我们不需要接触的编程语言的原始而抽象的底层形态。  </p>
<p><strong>让我们贴近机器数的底层表示吧！</strong> </p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/binary0_1.jpeg" alt="二进制的0和1"></p>
<p>上面是二进制的 0 和 1，也即机器所能理解的数据形式。但这对我们来说有意义吗？直到看到下图，我才知道（有人是黑客帝国粉吗？）</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/matrix.gif" alt="matrix"></p>
<p>我们进一步抽象这些二进制数字。看下面这段汇编：</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/assembly.png" alt="assembly"></p>
<p>你可能希望 R1、R2、R3 是整数，它们的类型其实在汇编语言层面无法确定。没有什么能阻止 R1、R2、R3成为任意类型，它们只是存在于寄存器内部的一堆 0 和 1。即使没有意义，加法运算也会将这三个数以按位累加，然后存储运算结果。</p>
<p>所以，「类型」的概念，源于更高级语言的更深层次的抽象，例如 <code>C</code>, <code>Go</code>, <code>Java</code>, <code>Python</code> 和 <code>TypeScript</code>，类型是语言自身的特性。</p>
<p>所以有些语言喜欢在运行时做类型检查，而有些喜欢在编译阶段做类型检查。</p>
<blockquote>
<p>译者注：即动态语言（解释型）与静态语言（编译型）的区别。Go是门静态强类型、编译型语言，同时因为 <code>interface</code> 的存在，让 Go 兼具动态性的优点。</p>
</blockquote>
<h3 id="所以，类型到底是什么？"><a href="#所以，类型到底是什么？" class="headerlink" title="所以，类型到底是什么？"></a>所以，类型到底是什么？</h3><p>各个编程语言中的类型的概念不尽相同，类型能以多种不同的方式表达，但它们还是有不少共通之处的。</p>
<ol>
<li>类型是一组值</li>
<li>在这组值上可以施加操作。如，整数类型可以施加 <code>+</code> 与 <code>-</code>，字符串类型可以拼接、空串检查等。</li>
<li>类型需要在 运行时 <code>runtime</code> 或编译期 <code>compile</code> 进行检查，确保数据的整体性，以及使得编译器按照开发者的意图来正确解析数据。</li>
</ol>
<blockquote>
<p>译者注：这里解释一下第三点。所有的数据，存储上的表现都是，占据了一段连续内存空间的值。  </p>
<p>以C语言和Go语言的结构体举例，什么是「数据的整体性」？  </p>
<p>我们来想想编译器如何能保证取出的某个结构体是完整的，而不是漏了或多了某个属性字段？很简单，每个结构体类型的长度是固定的，编译器只要在内存上取出连续的该结构体类型所占字节数的内存，就能保证取出的结构体是完整的。</p>
<p>什么是「使得编译器按照开发者的意图来正确解析数据」？</p>
<p>其实上面的例子已经隐含这个解析问题了，我们再举个更具体的例子。  </p>
<p>当取出了内存中的一段连续的内存后，怎么解析出内部的一个个字段属性呢？也很简单，按照字段的定义顺序，按字段类型的长度，依次解析。例如，结构体的第一个字段是 int32 类型，那么就取这段内存的前4个字节，解析成第一个字段（Go与C的结构体的起始地址都等于第一个字段的地址，这里应该还有内存对齐问题，有兴趣的读者可深入研究）</p>
</blockquote>
<p><strong>所以一个编程语言的类型系统，明确了某类型下的哪些操作是合法的。</strong></p>
<p>类型检查的目的是为了确保运算和操作只施加在正确的类型之上，并且程序必须遵循编程语言所定义的类型系统。类型检查可能是在编译期执行的，也可能是在「运行时」执行的。通过类型检查，可以使得数据以我们期望的形式被解释。因为在机器码执行阶段，不会有任何检查，全是二进制的 0 和 1。机器会无脑执行施加在二进制数据上的任何操作。</p>
<p>类型系统用来在二进制层面（原文 <code>bit patterns</code>）强制执行预期代码解释。例如，它保证了整数不会被施加任何非整数操作，从而得到无意义的结果。</p>
<p>一个类型系统由以下几部分组成：</p>
<ol>
<li><p><strong>基础类型</strong>——包含在该编程语言中，可用于以该编程语言编写的任何程序。Go 拥有许多基础类型，int8 , uint8 ( byte ), int16 , uint16 , int32 ( rune ), uint32。</p>
</li>
<li><p><strong>类型构造器</strong>——编程语言提供的定义新类型的途径。例如，定义一个 <code>T</code> 的指针类型 <code>*T</code>。</p>
<blockquote>
<p>（译者注：许多人认为Go的指针类型不是新类型，但其实任何类型的指针类型都是一个全新的类型，数组和切片也类似。如 <code>[]int</code> 和 <code>[3]int</code> 就是两种新类型。理解了这点，对底层数据类型的判断会有很大的帮助）</p>
</blockquote>
</li>
<li><p><strong>类型推断</strong>——编译器可以推断变量或函数的类型，而不需要显式声明它。Go 拥有 <em>单向类型推理</em> (<em>Uni-directional type inference</em>)。</p>
</li>
<li><p><strong>类型兼容</strong>——</p>
<ol>
<li>下面哪个赋值是被类型系统所允许的？<code>a int; b int8; a = b; </code></li>
<li>如何定义两个类型是否相等？——在[Go的可赋值判断](<a href="https://go.dev/ref/spec#Assignability">The Go Programming Language Specification - go.dev</a>)中主要由类型是否可以互换引用决定。我们等会会详细探讨。</li>
</ol>
</li>
</ol>
<h2 id="Go-语言的类型系统"><a href="#Go-语言的类型系统" class="headerlink" title="Go 语言的类型系统"></a>Go 语言的类型系统</h2><p>Go 有很多基础的规则来控制类型系统，这里我们只挑些重要的一起来看看。</p>
<p>但是，在抛下一切概念前，不如先看看我给你们准备的几个小例在子，它覆盖了一些 Go 类型系统的基础概念。我会在讲解重要概念的时候带你吃透这些例子。</p>
<p>先看看这些代码片段吧，哪些能成功通过编译，哪些不能，为什么？</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/type_system_figure1.png" alt="type_system_figure1"></p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/type_system_figure2.png" alt="type_system_figure2"></p>
<p>我希望你能写下自己的答案和理由，这样在最后我们就能一起探讨。</p>
<h2 id="有名类型（Named-Types）"><a href="#有名类型（Named-Types）" class="headerlink" title="有名类型（Named Types）"></a>有名类型（Named Types）</h2><p>也可被译作 「命名类型」。</p>
<p>诸如<code>int</code>, <code>int64</code>, <code>float32</code>, <code>string</code> 和 <code>bool</code> 等类型是预先定义（pre-declare）的。<strong>所有的预先定义的布尔型、数字型，字符串类型都是有名类型。</strong></p>
<blockquote>
<p>译者注：</p>
<p>内置字符串类型： string<br>内置布尔类型： bool<br>内置数值类型：</p>
<ul>
<li>int8、uint8（ byte）、int16、uint16、int32（ rune）、uint32、int64、uint64</li>
<li>float32、float64</li>
<li>complex64、complex128</li>
</ul>
</blockquote>
<p>同样的，任何通过「类型声明 <code>type declaration</code>」创建的新类型，也是有名类型。如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> <span class="comment">// named type</span></span><br><span class="line"><span class="keyword">type</span> myInt <span class="keyword">int</span> <span class="comment">// named type</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> <span class="comment">// named type</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>译者注：</p>
<ol>
<li>第一个和第三个是 Go 语言预定义类型</li>
<li>第二个用了类型定义，类型声明分为「类型定义」和「类型别名」两种。 <code>type myInt = int</code> 是类型别名。</li>
</ol>
</blockquote>
<p><strong>有名类型与定义类型，与其他类型都是永远不相等的</strong>。</p>
<h2 id="无名类型（Unnamed-Types）"><a href="#无名类型（Unnamed-Types）" class="headerlink" title="无名类型（Unnamed Types）"></a>无名类型（Unnamed Types）</h2><p>也可被译作「未命名类型」。</p>
<p><strong>复合（组合）类型</strong>——数组，结构体，指针，函数，接口，切片，映射和 channel ——都是无名类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">[]<span class="keyword">string</span> <span class="comment">// unnamed type</span></span><br><span class="line"><span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">// unnamed type</span></span><br><span class="line">[<span class="number">10</span>]<span class="keyword">int</span> <span class="comment">// unnamed type</span></span><br></pre></td></tr></table></figure>

<p>上面的「类型字面量」（类型字面量是一个用来表示混合值的概念）仅仅描述了复合类型是如何被组织的，类型本身并没有名字。</p>
<h2 id="底层类型"><a href="#底层类型" class="headerlink" title="底层类型"></a>底层类型</h2><p>每个类型 <code>T</code> 都拥有底层类型。  </p>
<ol>
<li><p>如果 <code>T</code> 是预定义的布尔、数字、字符串或类型字面量，它的底层类型就是它本身。</p>
</li>
<li><p>否则，<code>T</code> 的底层类型是其在类型声明时所引用的类型的底层类型。（译者注：即，在一个类型声明中，新声明的类型和原类型共享底层类型）</p>
</li>
</ol>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/underlying_types.png" alt="underlying_types"></p>
<p>让我们逐行分析：</p>
<ul>
<li>3 和 8：<code>string</code> 是底层预定义类型，所以底层类型是 <code>string</code> 本身</li>
<li>5 和 7：类型声明最右侧的是两个「类型字面量」，所以底层类型分别是 <code>map[string]int</code> 和 <code>*N</code> 。注意：类型字面量也是无名类型。</li>
<li>4、6 、10：它们的底层类型与类型声明时所引用的那个类型相同。译者注：<ul>
<li>4：与 <code>A</code> 的底层类型相同，即 <code>B</code> 的底层类型是 <code>string</code></li>
<li>6：与 <code>M</code> 的底层类型相同，即 <code>N</code> 的底层类型是 <code>map[string]int</code></li>
<li>10：与 <code>T</code> 的底层类型相同，即 <code>U</code> 的底层类型是 <code>map[S]int</code></li>
</ul>
</li>
</ul>
<p>让我们再看看第 9 行的 <code>type T map[S]int</code>。</p>
<p><code>S</code> 的底层类型是 <code>string</code>，所以，难道 <code>T</code> 的底层类型不应该是 <code>map[string]int</code> 吗？为什么是 <code>map[S]int</code> ？</p>
<p>因为我们在谈论 <code>map[S]int</code> 的底层无名类型时，在遇到第一个无名类型时就停止追溯（译注：<code>map[S]int</code>就是我们在递归寻找 <code>T</code> 的底层类型时遇到的第一个无名类型，立即停止）。或者正如 Go 语言规范上写的，如果 <code>T</code> 是类型字面量，那么它的类型就是它本身。</p>
<p>你可能会好奇，为什么我这么重视「无名类型」、「有名类型（定义类型）」和「底层类型」。因为它们在 Go 语言规范中扮演着重要的角色，使得我们的讨论能够继续。它能帮助我们理解，为什么上面贴的那些代码，有些长得几乎一样，但甚至过不了编译。</p>
<h2 id="可赋值性"><a href="#可赋值性" class="headerlink" title="可赋值性"></a>可赋值性</h2><p>关于一个值 <code>x</code> 是否可以赋值给一个 类型为 <code>T</code> 的变量，满足以下规则之一就可赋值（[译自Go语言可赋值性规则](<a href="https://go.dev/ref/spec#Assignability">The Go Programming Language Specification - go.dev</a>)）：</p>
<ul>
<li><p>x 的类型 与 T 相同。</p>
</li>
<li><p>x 的类型 V 和 类型 T 的底层类型相同，且 V 和 T 至少有一个不是 「定义类型（有名类型）」。</p>
</li>
<li><p>T  是接口类型，且 x 实现了 T 接口。</p>
</li>
<li><p>x 是双向 channel 值 ，T 是 channel 类型。x 的类型 V 和 T 拥有相同的元素类型，并且 V 和 T 至少有一个不是「定义类型」。</p>
<blockquote>
<p>译者注： <code>ch = make(chan int)</code>，其中 <code>int</code> 就是「元素类型」</p>
</blockquote>
</li>
<li><p>x 是预定义的 <code>nil</code> 值，T 是一个指针，函数，切片，映射，channel 或 接口类型。</p>
</li>
<li><p>x 的无类型的可被 T 类型表示的常量值</p>
<blockquote>
<p>译者注：如， <code>var num int = 1</code></p>
</blockquote>
</li>
</ul>
<p>虽然这些条件都是自解释的，我们还是一起来看看其中的一条吧。</p>
<p>规则：赋值时，两边的底层类型需要相同，并且至少要有一个不是「有名类型」。</p>
<blockquote>
<p>译者注：为什么这么多规则都强调了，至少有一个不是「有名类型」？读者可在看到「类型一致性」章节时留个心眼。</p>
</blockquote>
<p>我们再来看看前文的 Figure 4 和 Figure 5 所示代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Figure 5</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> aInt <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line">	<span class="keyword">var</span> ai aInt = <span class="number">100</span></span><br><span class="line">	i = ai</span><br><span class="line">	printAiType(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAiType</span><span class="params">(ai aInt)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(ai)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码不能通过编译，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8:4: cannot use ai (type aInt) as type int in assignment</span><br><span class="line">9:13: cannot use i (type int) as type aInt in argument to printAiType</span><br></pre></td></tr></table></figure>

<p>原因：<code>i</code> 是有名类型 <code>int</code>， <code>ai</code> 是有名类型 <code>aInt</code>，虽然它们的底层类型都是 <code>int</code>，但仍不能赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Firgure 4</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyMap <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">var</span> mMap MyMap</span><br><span class="line">	mMap = m</span><br><span class="line">	printMyMapType(mMap)</span><br><span class="line">	<span class="built_in">print</span>(m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printMyMapType</span><span class="params">(mMap MyMap)</span></span> &#123;</span><br><span class="line">	<span class="built_in">print</span>(mMap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码片段 4 能通过编译。因为 <code>m</code> 是无名类型 <code>map[int]int</code>，<code>mMap</code> 的底层类型和类型声明原类型 <code>MyMap</code> 的底层类型相同，都是 <code>map[int]int</code>， 即 <code>m</code> 和 <code>mMap</code> 的底层类型相同。</p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>一个非 常量的值 <code>x</code> 能被转换成类型 <code>T</code> ，当满足以下任何条件之一：[译自 Go 语言类型转换规则](<a href="https://go.dev/ref/spec#Conversions">The Go Programming Language Specification - go.dev</a>)</p>
<ul>
<li><p>x 可赋值给 T</p>
</li>
<li><p>忽略结构体 tag， x 的类型和 T 的类型拥有相同的底层类型。</p>
</li>
<li><p>忽略结构体 tag，x 的类型和 T 都是无名指针类型，并且他们的指针基类型拥有相同的底层类型。</p>
<blockquote>
<p>译者注：Go 语言中，改变结构体成员的相对位置，会得到一个新的结构体类型。</p>
</blockquote>
</li>
<li><p>x 的类型和 T 都是整数或浮点数指针类型。</p>
</li>
<li><p>x 的类型和 T 都是复数类型（complex）。</p>
</li>
<li><p>x 的是整数切片或字节（byte）切片或 runes 切片，T 是字符串类型。</p>
</li>
<li><p>x 是字符串， T 是 byte 或 runes 切片。</p>
</li>
<li><p>x 是切片，T 是指向数组的指针，并且切片和数组的基类型拥有相同的底层类型。</p>
</li>
</ul>
<p>看看 Figure 3。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// figure 3</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Meter <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Centimeter <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> cm Centimeter = <span class="number">1000</span></span><br><span class="line">	<span class="keyword">var</span> m Meter</span><br><span class="line">	m = Meter(cm)</span><br><span class="line">	<span class="built_in">print</span>(m)</span><br><span class="line">	cm = Centimeter(m)</span><br><span class="line">	<span class="built_in">print</span>(cm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码可编译通过，因为 <code>Meter</code> 和 <code>Centimeter</code> 的底层类型都是整型，且底层类型能相互转换。</p>
<p>在我们看 Figure1 和 Figure2 前，我们不妨一起研究下 Go 语言类型系统的另一个更为基础的规范。</p>
<h2 id="类型一致性"><a href="#类型一致性" class="headerlink" title="类型一致性"></a>类型一致性</h2><p><strong>两种类型要么相同，要么不同</strong>。</p>
<p>在通常的类型系统中，有两个标准方法来判断两个类型是否可视为同一类型。<strong>名字相同</strong> 和 <strong>结构相同</strong>。</p>
<p><strong>名字相同</strong> 是非常直观的：两个类型当且仅当类型名字相同时才相同。</p>
<p>所以，在 Go 语言里面，一个已定义的类型（有名类型），永远和其他类型不相同。因为两个有名类型的名字不可能相同。</p>
<p><strong>结构相同</strong>：两个类型当且仅当它们拥有相同的「结构（structure）」时才相同。</p>
<p>在 Go 语言中，当两个类型结构相同且不是有名类型时，类型才相同。</p>
<p>所以，甚至 Go 语言中预定义的 有名类型/定义类型，例如，<code>int</code> 和 <code>int64</code> 也不是相同类型。并且，Go 语言接口类型的可赋值性也取决于 [结构类型系统（Structural type system）](<a href="https://en.wikipedia.org/wiki/Structural_type_system">Structural type system - Wikipedia</a>) 。 <strong>Go 语言没有 Duck Type</strong>。</p>
<p>(下面是[原作者义愤填膺的推特](<a href="https://twitter.com/in_aanand/status/1072476894308773888?ref_src=twsrc%5Etfw%7Ctwcamp%5Etweetembed%7Ctwterm%5E1072476894308773888%7Ctwgr%5E%7Ctwcon%5Es1_&ref_url=https://cdn.embedly.com/widgets/media.html?type=text2Fhtmlkey=a19fcc184b9711e1b4764040d3dc5c07schema=twitterurl=https3A//twitter.com/in_aanand/status/1072476894308773888image=https3A//i.embed.ly/1/image3Furl3Dhttps253A252F252Fpbs.twimg.com252Fprofile_images252F1097738091530342400252FFS0a8_YX_400x400.png26key3Da19fcc184b9711e1b4764040d3dc5c07">Ankur Anand 在 Twitter: “There is No “Duck typing in @golang”. Go uses “structural typing” on methods to determine the compatibility of a type with an interface, not “Duck Typing”. I Repeat There is <em>NO</em> Duck Typing in #golang. Unfortunately, many articles on the web have got it wrong. 😇” / Twitter</a>)) 译者保留意见。</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/type_system_twitter.png" alt="type_system_twitter"></p>
<p>下面我们来看看结构体的转换：</p>
<p>规则：忽略结构体 tag，x 的类型和 T 拥有相同的底层类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// figure 2</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Meter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Centimeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cm := Centimeter&#123;</span><br><span class="line">		value: <span class="number">1000</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m Meter</span><br><span class="line">	m = Meter(cm)</span><br><span class="line">	<span class="built_in">print</span>(m.value)</span><br><span class="line">	cm = Centimeter(m)</span><br><span class="line">	<span class="built_in">print</span>(cm.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意规则：<strong>相同的底层类型</strong>。  </p>
<p>因为结构体域 <code>Meter.Value</code> 的底层类型是 <code>int64</code>， 而 <code>Centimeter.Value</code> 的底层类型是 <code>int32</code>，它们不是同一类型，因为「有名类型（定义类型）」永远与其他类型不同。</p>
<p>再来看看代码段 1</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// figure 1</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Meter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Centimeter <span class="keyword">struct</span> &#123;</span><br><span class="line">	value <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cm := Centimeter&#123;</span><br><span class="line">		value: <span class="number">1000</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> m Meter</span><br><span class="line">	m = Meter(cm)</span><br><span class="line">	<span class="built_in">print</span>(m.value)</span><br><span class="line">	cm = Centimeter(m)</span><br><span class="line">	<span class="built_in">print</span>(cm.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>Meter.Value</code> 的底层类型和 <code>Centimeter.Value</code> 的底层类型都是 <code>int64</code>，所以类型转换能通过编译。</p>
<p>原作者：我希望这篇文章能在 Go 型系统上为您提供一些新的见解，而我在写这篇文章的时候也获得了新的洞见。</p>
<blockquote>
<p>译者：俺也一样！翻译一遍和简单读一遍收获完全不一样。</p>
</blockquote>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li>原文（需科学上网）：<a href="https://medium.com/@ankur_anand/a-closer-look-at-go-golang-type-system-3058a51d1615">A closer look at Golang type system | by Ankur Anand | Medium</a></li>
<li><a href="https://github.com/golang101/golang101">golang101——第14章 go 类型系统概述</a></li>
</ol>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>好文翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>厚脸皮：从入门到实践</title>
    <url>/2021/11/%E5%8E%9A%E8%84%B8%E7%9A%AE%EF%BC%9A%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>本文是我克服社交恐惧的一些个人经验，希望能给读这篇文章的你带来些帮助。</p>
<p>我所指的厚脸皮是在<strong>真诚与尊重他人</strong>的基础上，能勇敢地做自己，拥有被讨厌的勇气。让别人感到不舒服的行为，不叫厚脸皮，叫冒犯。</p>
<h2 id="心法一：别人没有那么在意你"><a href="#心法一：别人没有那么在意你" class="headerlink" title="心法一：别人没有那么在意你"></a>心法一：别人没有那么在意你</h2><p>又名：<strong>每个人的中心都是自己</strong></p>
<span id="more"></span>

<p>还是那个老掉牙的例子，一个律师从来没有败过官司，终于有一天他输了一场。他惴惴不安，不敢和同行说，认为自己会被嘲笑，然后失去工作，引发一系列连锁反应。在心理咨询师的劝导下，他在晚会上一个个和大家聊天，说自己败了官司。</p>
<p>然而大家的反应大概有这么几种：</p>
<ol>
<li>压根没接他这个败官司的话题，重开了一个话题</li>
<li>不以为意，屁大点的事，谁没败过官司？</li>
</ol>
<p>演讲需要很厚的脸皮，我们就<strong>以演讲为例子</strong>一起来看看吧</p>
<p>大多数人演讲的时候非常紧张，一直在关注台下的人对自己演讲的反馈如何。可能你常常因为认真听的人少而气馁，越来越越不敢表现自己。</p>
<p>我的发言得不到良好的反馈，我为什么要再发言？我也不敢啊！</p>
<p>但其实，换个角度，其实别人更关心自己。他们顶多觉得讲的无聊，然后自顾自做自己的事。没有人会因为演讲者讲得不好，心生诋毁之意。如果真的有，那么 TA 是 **，没有必要较真。</p>
<p>只要我们足够真诚，无论是对自己，还是对他人，就能最大程度换得同等的尊重。</p>
<p>我们都是普普通通的存在，没有必要一定引起别人的关注，这只是「廉价的优越性追求」。拥有甘于平凡的勇气，也就有了自由做自己的能力，自然不会在意别人的眼光。</p>
<h2 id="心法二：不要过度期待他人的回应"><a href="#心法二：不要过度期待他人的回应" class="headerlink" title="心法二：不要过度期待他人的回应"></a>心法二：不要过度期待他人的回应</h2><p>又名：<strong>不要试图抓住自己掌控不了的东西。</strong></p>
<p>我们已经通过心法一克服了对他人恶意行为的惧怕，新的问题是，我们常常过度期待他人的回应。</p>
<p>很多人都是因为期待听众有很好的反馈，实际演讲却得不到反馈，逐渐怯场，不敢表现自己。怎么解决呢？</p>
<p>我们为什么一定要期待别人的回应呢？</p>
<p>别人是别人，我是我，为什么妄图控制别人的任何行为呢？</p>
<p>我们能掌控的只有自己，别人的手、眼、口不长在自己的身上，无法直接控制。对于别人，我们只能尽可能地去影响他人，而不能强行改变。也没有必要因为期待别人提供的正向反馈才去做这件事，这样的动机是歪的，是功利性的。我们所能做的，就是提升自身的演讲技巧，多下功夫，大家感受到了我们的用心，都会愿意包容的。</p>
<p>我们可以用激情有趣的演讲去感染听众，这是前文说的影响；而不是说，大家都把手机放下听我讲，这是控制（强行改变）。他们听不听，是他们自己的事情，我们只要做好属于自己的事情就好。</p>
<p>没有人能做到每个听众都如自己所愿的，越是追求期待，越是容易走火入魔。只要认真做好自己的事，认同我们的人会越来越多的。</p>
<p><strong>如果企图通过他人对自己的回应来判断自己的成功与否，那么就把自己快乐的权利拱手让人了。</strong></p>
<h2 id="心法三：决定自己快乐的权利，在自己手上"><a href="#心法三：决定自己快乐的权利，在自己手上" class="headerlink" title="心法三：决定自己快乐的权利，在自己手上"></a>心法三：决定自己快乐的权利，在自己手上</h2><p>又名：<strong>改变价值感的来源</strong></p>
<p>又名：<strong>人生的意义，由自己决定</strong></p>
<p>又名：<strong>活在当下</strong></p>
<p>前面讲到，我们不应该期待别人的回应。可是，不从别人的正向反馈中汲取能量，我们又怎么获得「自我实现」呢？</p>
<p>本质上，他人的赞赏与肯定，最终都会转化成自我认同。</p>
<p>这种被认同感，被肯定感，自我价值感，可以不只来源于别人，也可以来源于自己。</p>
<p>我们可以把关注点逐转移到自己身上来。从获得赞赏这个时间点，往前推，我们可以为自己演讲时的精彩表现而自豪，为自己的良好状态而自豪，为自己的进步而自豪。再往前推，在决定走上台的那一刻，在举手决定演讲的那一刻，我们就突破了自己，就赢了。</p>
<p>人生就像是在每一个瞬间不停旋转起舞的连续的刹那，没有什么绝对的目标和目的地，只要此时此刻跳着舞的我们，感到充实快乐，就足够了。蓦然四顾，会惊奇地发现，「已经来到这里了吗」。</p>
<p>我曾经对未来感到绝望，因为我根本想不出未来会是什么样子，自己长什么样子，如何生活，又有哪些人还在我身边。后来想通了，不是没有未来才想不出未来是什么样子，而是未来是由现在的一个个小瞬间组成的，未来拥有无限可能。一眼能望到边的人生，也没有什么意思。</p>
<p>拉到演讲这个小场地来，我们的每一个举动，无论是决定举手上台演讲，还是演讲时讲出的每一个字、每一个动作，都是当时的「此时此刻」，只要认真把握那一刹那，就够了。 </p>
<p>一直沉浸在过去的阴影中，或者担忧未来的时候，哪还有精力活好此时此刻。未来也是由每一个此时此刻构成的。</p>
<p>这里再扯远些，说说价值感的来源。</p>
<p>从另一个角度来说，获得赞赏与肯定，也是因为自己能够对别人有所贡献。每个人都能从一句「谢谢」中汲取极大的能量，它甚至能把一个对世界无望的人从死神手中拉回。我是一个极度喜欢帮助别人的人，比如非常喜欢教别人，别人请教我东西，我反而会怕讲不清楚给对方带来困扰。最后，非常享受那种「被需求」感。</p>
<p>但是，我们是否只有在获得了别人的感谢之后，才能有幸福感呢？又或者说，我们帮助别人的动机，是为了自我实现，还是为了获得表扬？这是有区别的。后者，在未获得表扬的时候，容易自我怀疑、心生怨恨、功利性。前者，我们在做出了服务他人这一举动的行为的时候，只是单纯的思考「我能够为他人做些什么」，主观上就能够认为「我能够对他人作出贡献」，就已经完成了自我价值感的获得。至于后面，别人是否感谢我们，那就是别人的事情了，没有的话无所谓，有的话，锦上添花。</p>
<p>不用怀疑自己是否会为他人带来多大的价值，当我们担心无法为社会作贡献的时候，就已经为了社会、他人而作出贡献了。甚至有哲人认为，只要存在着，就有价值。</p>
<p>当我们觉察到自身拥有的巨大的价值时，也就拥有了做任何事的勇气。这个价值源于他者贡献，但是判断准则可以在自己心中。</p>
<h2 id="心法四：释放自我的枷锁"><a href="#心法四：释放自我的枷锁" class="headerlink" title="心法四：释放自我的枷锁"></a>心法四：释放自我的枷锁</h2><p>又名：<strong>目的论的应用</strong></p>
<p>又名：终于快写完了</p>
<p>看到这里，你可能会说，可我就是有这样那样的原因，迈不出第一步啊？</p>
<p>很多人都有不愿提及的回忆，甚至原生家庭带来的心理创伤，各种恐惧与担忧，做事小心翼翼。</p>
<p>但是，再怎么找原因，能做什么，敢做什么，还是不会改变。</p>
<p>决定我们自身的不是过去的经历，而是我们自己赋予经历的意义。</p>
<p>我把所有的负面情绪、悲伤经历，都当成一种「信号」，把它当成身体和大脑与自己对话的一种方式。它们存在的意义，只是捎个话罢了，话捎到了，他们的使命也就结束了，不必太过好客，非得留下吃个晚饭，甚至一住就是几年。</p>
<p>举个形象的例子，百米赛跑，信号枪响了，是接受到信号后，马上联想到信号代表起跑，然后专心跑步。还是，沉浸在信号枪声中，疯狂回忆？</p>
<p>过去的事情已经发生了，就随它去吧，与其努力治愈，不如想想以现在自己所拥有的一切，能做些什么，该做些什么，然后大胆去做，专注于每时每刻。做着做着，前事对自己的影响，就会越来越弱，我们渐渐也会发现，其实它们没有自己想象的那么可怕。</p>
<p>扯回本段标题，何为<strong>自我的枷锁</strong>？</p>
<p>我们每个人，多多少少都会觉得，这些东西不是我能做的，我真的做不了。我完全没有做这个的能力，或者我做了之后，会发生不可掌握的情况。</p>
<p>可是，当我们真正去做了，又会发生什么呢？——什么也不会发生，在我们真正做之前，不可能知道会发生什么。</p>
<p>还是，我们只是把这个，当成不去做的借口，当成自己的护身符呢？</p>
<p>人们常常找这样那样的借口，「下定决心不改变」。做出改变是很痛苦的，待在现在的环境中，虽然常有不快，但却是稳定的、安心的。——这就是「自我的枷锁」了。</p>
<p>自我的枷锁，说来也搞笑，我曾经给自己设过「不能去某些餐厅，因为我不配」的限。现在的我，连盖浇饭都敢吃了（以前饭菜一混吃就会吐）。或许在读这篇文章的你，也有像我这样的奇奇怪怪的自我限制，但仔细想想也会发现，这些限制是多么可笑。</p>
<p>我们是先有了「避免在交际中受伤」的目的，才决定了不去改变。</p>
<p>但无论过去发生了什么，我们仍然可以重新选择自己的生活方式，与过去的自己彻底告别。</p>
<p>为什么要讨厌自己，我们现在都能决定如何度过自己的每时每刻，起码能决定自己对每一件事的自我解释与做它时的心情。</p>
<p>发自内心地接纳自己的一切，想想哪些是自己真正不能做的，哪些是自己认为自己不能做的。</p>
<p>然后接受自己的不足，自己实现无法改变的，例如生理缺点、生老病死，就随它去吧——怎么努力也改变不了，何必给自己添堵。</p>
<p>接受自己的不完美，不必纠结，把精力用在突破自我枷锁，去做那些自己其实完全能做，但一直觉得自己做不了的事情吧。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>本文源于《被讨厌的勇气》一书的极小部分章节，以及自己一年多对本书的实践与感悟。有兴趣的话建议阅读原著，我只是讲了书中内容的冰山一角。</p>
<p>最后，祝愿大家都能拥有被讨厌的勇气和幸福的勇气。</p>
<p>—— 爱飞的鸟</p>
<p>—— 2021年11月21日 1点20分</p>
]]></content>
      <tags>
        <tag>被讨厌的勇气</tag>
      </tags>
  </entry>
  <entry>
    <title>我与阿德勒</title>
    <url>/2021/11/%E6%88%91%E4%B8%8E%E9%98%BF%E5%BE%B7%E5%8B%92/</url>
    <content><![CDATA[<p>很早就想写写关于「阿德勒」的一些东西了，前些天交了心理作业，所谓的契机就这么来了。我是从《被讨厌的勇气》一书知晓阿德勒的，对话体，作者是「岸见一郎」与「古贺史健」。可以说，是阿德勒赋予了我新生。</p>
<span id="more"></span>



<p>从知道这本书到现在，差不多刚好一年，在反复阅读与实践的过程中，也有了些自己的理解。我所讲述的内容，一定只是《勇气》这本书的「有失偏颇」的理解，但这正是属于我的、和阿德勒的故事。</p>
<p>本文长期更新，想到什么就写什么，有了新的领悟和体会就再更新。</p>
<h2 id="一、目的论"><a href="#一、目的论" class="headerlink" title="一、目的论"></a>一、目的论</h2><p>先下结论，目前而言，目的论给我带来的最大的帮助是，把我的注意力从分析痛苦并沉浸其中，转移到了如何行动起来，切实去改变。</p>
<p>目的论是帮助我走出去年噩梦的几大核心思想之一。与目的论相对的，是弗洛伊德的原因论。</p>
<p>举个例子，一位青年闭门不出，甚至一踏出房间马上就会心悸不已、手脚发抖，原因也许是与父母关系不合。若是弗洛伊德，会从原生家庭等角度分析青年不敢出门的原因，而阿德勒却说，这样的分析会使人陷入决定论，即，现在乃至未来都由过去的事情决定。阿德勒认为，这些症状正是青年因为达到「不出去」的目的而制造出来的。比如，他这样下去，母亲就会一直关照他。</p>
<p>再举个例子，你去看医生，你是希望医生分析你生病原因，还是嘱咐你具体怎么做？</p>
<p>另一个例子，服务员不小心把咖啡倒在了顾客身上，顾客大发雷霆。阿德勒从目的论的角度出发，说，顾客是「为了表现自己很生气，想让服务员难堪」才生气的，而不是因为被泼了咖啡生气。因为最原始的气愤，只在刚开始的那一瞬间，后面怎么做，都是可以由自己决定的。</p>
<p>阿德勒认为，心理创伤并不存在，所以的愤怒都是捏造的，所有的不幸皆是自己选择的。</p>
<p>阿德勒的目的论是非常激进的，我只是非常片面地描述了目的论，后面还有很多细节没有讲述，尤其是那些振聋发聩的推演过程。目前本篇文章不是为了讲解阿德勒思想的，更多是为了表述它对我的改变，所以逻辑链可能有些混乱，敬请谅解。</p>
<p>重要的不是过去发生了什么，而是，你是如何解释它的。</p>
<p>重要的不是过去发生了什么，而是，你从现在的拥有的一切出发，能做些什么。</p>
<p>我想到过一个很形象的例子，关于如何看待「痛苦」以及任何负面情绪。我不开心的时候，会把这些情绪当成身体向我发送的信号，告诉我该调整了，而不会沉浸在负面情绪本身中。百米赛跑，信号枪响了，你是回味信号枪声，还是撒腿就跑？</p>
<p>情绪作为一种信号源，你感受到了它对你的反馈，它的使命就结束了，不必再沉浸。</p>
<p>上面讲述的更多是关于目的论在克服负面情绪上的应用，实际上，它对各种逃避拖延，也是很有帮助的，只是上次心理作业的题目是谈谈自己客服沮丧情绪的方法，所以我的手稿往这方面偏向些。</p>
<h2 id="二、课题分离"><a href="#二、课题分离" class="headerlink" title="二、课题分离"></a>二、课题分离</h2><p>未完待续</p>
]]></content>
      <tags>
        <tag>被讨厌的勇气</tag>
      </tags>
  </entry>
  <entry>
    <title>代码重构实战（一）课表查询</title>
    <url>/2021/11/%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84%E5%AE%9E%E6%88%98%EF%BC%88%E4%B8%80%EF%BC%89%E8%AF%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>你永远想象不到代码能被重构成什么样子，重构之路充满了惊喜。——我自己</p>
<p>如果不信，请直接跳转到文末。</p>
<p>这本是我交给社团新人的一个重构任务，但后面自己手痒，在他的基础上，又重构了几版。个人自大一波，认为从本次重构中领悟了很多东西，希望也能给读者带来些帮助。本文是基于 Go 语言的，但是在解释思想时，绝大部分内容不涉及特定语法，适合所有开发者阅读。在此感谢 Atom 、Eson 与我进行的讨论、提供的建议，给我带来了非常大的帮助与启发（尤其是代码直观性方面的保持，不要为了重构而重构）。也感谢 Dolt 的初次重构。</p>
<span id="more"></span>

<h2 id="一、项目背景介绍"><a href="#一、项目背景介绍" class="headerlink" title="一、项目背景介绍"></a>一、项目背景介绍</h2><p>本项目是社团微信公众号的后台代码，本文只关注 <code>schedule</code> 模块：根据微信传来的学号，以及触发词，返回「今日课表」或「明日课表」。</p>
<p>微信端主要是调用了社团上游的课表查询接口，处理初始课表信息，以及封装至微信公众号内。</p>
<p>本模块原始代码因为大佬写得比较赶，所以没有注意封装，大家勿喷。项目其他地方，例如模块可插拔，设计得非常非常优雅，实在佩服。</p>
<p>更确切地说，本次代码重构只针对模块的消息路由注册部分。</p>
<h2 id="二、原始代码"><a href="#二、原始代码" class="headerlink" title="二、原始代码"></a>二、原始代码</h2><p>Hexo 貌似没有原生代码折叠语法支持，就先全部展开吧。：）还是 Github 折叠香</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(message.MsgTypeText), <span class="string">&quot;今日课表&quot;</span>, server.KeywordTypeEqual, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(<span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span>)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(m.generateScheduleTodayMessage(msg.GetUserID()))&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(message.MsgTypeText), <span class="string">&quot;明日课表&quot;</span>, server.KeywordTypeEqual, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(<span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span>)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(m.generateScheduleTomorrowMessage(msg.GetUserID()))&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(message.EventClick, <span class="string">&quot;今日课表&quot;</span>, server.KeywordTypeEqual, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(<span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span>)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(m.generateScheduleTodayMessage(msg.GetUserID()))&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(message.EventClick, <span class="string">&quot;明日课表&quot;</span>, server.KeywordTypeEqual, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(<span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span>)&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(m.generateScheduleTomorrowMessage(msg.GetUserID()))&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这串代码，主要传入了两个变量  </p>
<ul>
<li>查哪天的课表：目前有两种可能，<code>今日课表</code>、<code>明日课表</code>。以后可能会加。</li>
<li>支持的微信触发类型：<code>MsgTypeText</code> ：发文字消息触发，<code>MsgTypeClick</code>：菜单点击触发</li>
</ul>
<p>两两组合，一共组合出了四种消息处理路由。  </p>
<p>赶 ddl 赶出来的代码，可重构的点太多，大家都应该有自己的想法，就不讲了。</p>
<h2 id="三、新人重构后"><a href="#三、新人重构后" class="headerlink" title="三、新人重构后"></a>三、新人重构后</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	setMsgHandler(s, m, <span class="string">&quot;今日课表&quot;</span>, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, <span class="string">&quot;明日课表&quot;</span>, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, <span class="string">&quot;今日课表&quot;</span>, message.EventClick)</span><br><span class="line">	setMsgHandler(s, m, <span class="string">&quot;明日课表&quot;</span>, message.EventClick)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMsgHandler</span><span class="params">(s *server.Server, m *module, key <span class="keyword">string</span>, msgType message.MsgType)</span></span> &#123;</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(msgType), key, server.KeywordTypeEqual, <span class="number">1</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">server</span>.<span class="title">MessageHandlerFunc</span></span> &#123;</span><br><span class="line">		method := m.generateScheduleTodayMessage</span><br><span class="line">		<span class="keyword">if</span> key == <span class="string">&quot;明日课表&quot;</span> &#123;</span><br><span class="line">			method = m.generateScheduleTomorrowMessage</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(<span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span>)&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(method(msg.GetUserID()))&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先看看 Dolt 的重构逻辑，简单粗暴地把那四种组合，封装成了一个函数，即 <code>setMsgHandler</code>，传参就传在变动的两个内容：「天数」和「消息」类型。</p>
<p>好处在于，未绑定消息提示只有一份了，以后想改话术不用改多次也不用担心话术不一致问题。以及，封装了重复的函数。</p>
<h3 id="3-1-对新人重构的修改一"><a href="#3-1-对新人重构的修改一" class="headerlink" title="3.1 对新人重构的修改一"></a>3.1 对新人重构的修改一</h3><p>先看这段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(<span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span>)&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(method(msg.GetUserID()))&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来分析下这段代码做了什么。</p>
<p>判断 <code>userID</code> 是否是空</p>
<ul>
<li>如果是空，那么就返回 <code>message.Reply</code> 结构体<ul>
<li>消息设置为未绑定提示</li>
</ul>
</li>
<li>非空，返回 <code>message.Reply</code> 结构体<ul>
<li>消息设置为格式化后的课表字符串</li>
</ul>
</li>
</ul>
<p>我认为，上述代码段的两个 <code>return</code>，应当合并为一个，理由如下：</p>
<p><strong>从代码阅读者视角说</strong>  </p>
<p>首先，后面阅读该代码的人，需要先明白这是个 <code>if else</code> 结构。然后，正常人，会非常仔细地对比这两个 <code>return message.Reply</code> 内的结构体元素，是否完全一致，到底是哪个元素发生了变化。光是这两行代码的元素对比，起码就要耗时 10 秒。  </p>
<p>既然代码编写者知道这两行函数只有最后发送的消息不同，那么为什么在写代码的时候就体现出来？而不是说，在其他人日后阅读代码的时候，一个一个元素对比。我觉得这非常不优雅。  </p>
<p><strong>从代码整洁度视角说</strong> </p>
<p>代码发生了大幅度相似、重复，整洁度不言而喻。      </p>
<p>以及，未绑定信息提示太长了，已经超出 80 列了，建议定义成一个常量，传入函数调用中。</p>
<p>我是这么改的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unBind := <span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span></span><br><span class="line"><span class="keyword">var</span> messageReply <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	messageReply = unBind</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	messageReply = scheduleString</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(messageReply)&#125;</span><br></pre></td></tr></table></figure>

<p>首先从感官上，这段代码，没有被浏览器渲染成两行，看起来非常舒适。  </p>
<p>然后，读代码的时候，不会有任何歧义，也不会有干瞪眼比对元素是否相同的情况。  </p>
<h3 id="3-2-对新人重构的修改二"><a href="#3-2-对新人重构的修改二" class="headerlink" title="3.2 对新人重构的修改二"></a>3.2 对新人重构的修改二</h3><p>再看看这段</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">method := m.generateScheduleTodayMessage</span><br><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;明日课表&quot;</span> &#123;</span><br><span class="line">	method = m.generateScheduleTomorrowMessage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相信读者看到这段的感受都是迷惑的，看了半天，才反映到，这是个 <code>if else</code>。如果传 <code>今日课表</code> ，就调用查询今天课表的函数， 如果传 <code>明日课表</code> ，就调用查询明天课表的函数。</p>
<p>他先定义了一个默认值 <code>今日课表</code>，然后用 <code>if</code> 判断，如果命中了就覆盖。</p>
<p>如果后来的调用者，传了个 <code>后天课表</code> ，而没有注意到这个函数的内部实现，那么，就崩了啊，bro~ 最后返回的，是 <code>今日课表</code> 。</p>
<p>如果改成这样呢：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key = <span class="string">&quot;今日课表&quot;</span> &#123;</span><br><span class="line">    method := m.generateScheduleTodayMessage</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	method = m.generateScheduleTomorrowMessage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果后面的调用者，又没看你函数的内部实现，传了个 <code>后天课表</code>，又炸了呀，宝友，这可不兴写！  </p>
<p>你返回的，会是，明天的课表。</p>
<p>所以我个人推荐，<strong>所有的已知的判断条件，全部手动硬匹</strong>，<code>else</code> 只用来处理未知情况。代码如下：  </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> key == <span class="string">&quot;今日课表&quot;</span> &#123;</span><br><span class="line">    method := m.generateScheduleTodayMessage</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> key == <span class="string">&quot;明日课表&quot;</span> &#123;</span><br><span class="line">	method = m.generateScheduleTomorrowMessage</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 报错或直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，如果有人调用函数，传了个非法值，会直接收到报错。</p>
<h3 id="3-3-对新人重构的修改三"><a href="#3-3-对新人重构的修改三" class="headerlink" title="3.3 对新人重构的修改三"></a>3.3 对新人重构的修改三</h3><p>这段涉及到 Go 的语法了，不会 Go 的读者可以跳过。</p>
<p>新人的问题主要在于，写了无必要的函数嵌套。本来只要返回个函数就行，而他写了个匿名函数来返回这个函数。不但增加了无必要的代码层级，还大大降低了可读性。（我太菜了，那天 review 了半天，才注意到后面有个 <code>()</code>）</p>
<p>怎么改的话，直接贴个示意图吧，应该能看懂。  </p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211103112808000.png" alt="image-20211103112808000"></p>
<h2 id="四、继续重构？"><a href="#四、继续重构？" class="headerlink" title="四、继续重构？"></a>四、继续重构？</h2><p>按照之前的修改，改完后是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	setMsgHandler(s, m, today, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, tomorrow, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, today, message.EventClick)</span><br><span class="line">	setMsgHandler(s, m, tomorrow, message.EventClick)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMsgHandler</span><span class="params">(s *server.Server, m *module, key <span class="keyword">string</span>, msgType message.MsgType)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> method <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span><span class="title">string</span> // 通过学生 <span class="title">id</span> 获取课表字符串的函数签名</span></span><br><span class="line">    <span class="keyword">if</span> key == <span class="string">&quot;今日课表&quot;</span> &#123;</span><br><span class="line">        method := m.generateScheduleTodayMessage</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> key == <span class="string">&quot;明日课表&quot;</span> &#123;</span><br><span class="line">        method = m.generateScheduleTomorrowMessage</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 报错或直接返回</span></span><br><span class="line">	&#125;</span><br><span class="line">	msgHandleFunc := <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		unBind := <span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span></span><br><span class="line">		<span class="keyword">var</span> messageReply <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			messageReply = unBind</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messageReply = method(msg.GetUserID())</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(messageReply)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(msgType), key, server.KeywordTypeEqual, <span class="number">1</span>, msgHandleFunc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还能再优化吗？</p>
<p>其实在重构这个文件前，我已经重构过本模块的另外一份代码，其中采纳了 Atom 的建议，感谢。  </p>
<p>项目中，生成今日课表或明日课表的代码，其实是这样的：  </p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211103134755254.png" alt="image-20211103134755254"></p>
<p>之前对今日课表和明日课表的查询是完全独立的两个函数，在这次重构之前，我重构了课表消息缝合函数（就是前文说的两个获取今日课表获取明日课表函数）。写了个通过日期偏移，获取任何一天课表的函数。<code>dayOffset</code> 是我为了增强可读性而定义的新类型，本质就是 <code>int</code>，没学过 Go 的读者可以这么理解。</p>
<p>当时为了不影响调用方（即今天重构的消息路由注册函数），只改了函数体，函数头保留了。</p>
<p>今天算是看完了整个模块。既然消息路由的传参是日期偏移，同学查课表的参数也是偏移，那么为什么不统一一下？  这样的话，不但能删除这两个「生成今日课表」、「生成明日课表」的函数，以后如果要增加支持课表查询的天数，也不需要新增函数。</p>
<p>改完之后是这样的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMsgHandler</span><span class="params">(s *server.Server, m *module, offset dayOffset, msgType message.MsgType)</span></span> &#123;</span><br><span class="line">	msgHandleFunc := <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> dayOffset == today &#123;</span><br><span class="line">        	key = <span class="string">&quot;今日课表&quot;</span></span><br><span class="line">    	&#125; <span class="keyword">else</span> <span class="keyword">if</span> dayOffset == tomorrow &#123;</span><br><span class="line">        	key == <span class="string">&quot;明日课表&quot;</span></span><br><span class="line">    	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    		<span class="comment">// 报错或直接返回</span></span><br><span class="line">		&#125;</span><br><span class="line">		unBind := <span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span></span><br><span class="line">        <span class="comment">// 这里以后就不用再写 if 了</span></span><br><span class="line">		scheduleString := m.generateScheduleMessageByOffset(msg.GetUserID(), offset)</span><br><span class="line">		<span class="keyword">var</span> messageReply <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			messageReply = unBind</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			messageReply = scheduleString</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(messageReply)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(msgType), key, server.KeywordTypeEqual, <span class="number">1</span>, msgHandleFunc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="五、还能再优化吗"><a href="#五、还能再优化吗" class="headerlink" title="五、还能再优化吗"></a>五、还能再优化吗</h2><p>对于大部分人来说，优化到现在就差不多了。</p>
<p>但我们现在再从程序的<strong>拓展修改</strong>角度，或者有点像，「开闭原则」，评价一下这个程序。</p>
<p>看看上面这段代码，<code>setMsgHandler</code> 内有一个将 <code>dayOffset</code> 的数值转化成中文 <code>今日课表</code>、<code>明日课表</code> 的判断。</p>
<p>如果我们想增加或删减课表查询的天数，比如增加「明日课表」，必须要对 <code>setMsgHandler</code> 进行一个修改。</p>
<p>这又有个同步问题，如果新开发者调用了 <code>setMsgHandler</code> 函数，传入了 <code>后天</code> 的 <code>dayOffset</code> ，却没有修改函数内 <code>dayOffset</code> → 中文触发词（如 <code>后天课表</code>）的转化。</p>
<p>那就，又寄了啊，姐妹！</p>
<p>我们能不能做到，在拓展功能的情况下，不修改 <code>setMsgHandler</code> 函数？</p>
<p>即，后面的调用者，能不能把 <code>setMsgHandler</code>，当成一个类似于 <code>包内函数</code> 的东西，完全不用关心内部实现，调用的时候不做任何修改？并且不会出现任何同步问题？</p>
<p>很简单，维护一个 键为 <code>dayOffset</code>，值为 <code>今日课表</code>、<code>明日课表</code> 等的 <code>map</code> 就行。函数体内，只要实现 <code>map[key]</code> 语法就好。  </p>
<p>通用实现是用 <code>map</code>，但 Go 有更优雅的方式，用接口。  </p>
<p>当前版本完整代码如下：  </p>
<p>（上下两部分在两个文件源文件内，为了阅读方便，函数放到了一起）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	today dayOffset = <span class="literal">iota</span></span><br><span class="line">	tomorrow</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就是我所谓的 Go 的接口实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(offset dayOffset)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">map</span>[dayOffset]<span class="keyword">string</span>&#123;</span><br><span class="line">		today:    <span class="string">&quot;今日课表&quot;</span>,</span><br><span class="line">		tomorrow: <span class="string">&quot;明日课表&quot;</span>,</span><br><span class="line">	&#125;[offset]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	setMsgHandler(s, m, today, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, tomorrow, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, today, message.EventClick)</span><br><span class="line">	setMsgHandler(s, m, tomorrow, message.EventClick)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMsgHandler</span><span class="params">(s *server.Server, m *module, offset dayOffset, msgType message.MsgType)</span></span> &#123;</span><br><span class="line">	msgHandleFunc := <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		unBind := <span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span></span><br><span class="line">		scheduleString := m.generateScheduleMessageByOffset(msg.GetUserID(), offset)</span><br><span class="line">		<span class="keyword">var</span> messageReply <span class="keyword">string</span></span><br><span class="line">		<span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			messageReply = unBind</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			messageReply = scheduleString</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(messageReply)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// offset 调用 String 接口，实现类似 map 效果，直接获得 天数偏移对应的  中文</span></span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(msgType), offset.String(), server.KeywordTypeEqual, <span class="number">1</span>, msgHandleFunc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="六、什么，还能更优雅？"><a href="#六、什么，还能更优雅？" class="headerlink" title="六、什么，还能更优雅？"></a>六、什么，还能更优雅？</h2><p>继续从拓展与修改的角度来看，我们来看看 <code>Server</code> 函数，这个函数是我们之前四个路由注册函数的调用方。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	setMsgHandler(s, m, today, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, tomorrow, message.MsgTypeText)</span><br><span class="line">	setMsgHandler(s, m, today, message.EventClick)</span><br><span class="line">	setMsgHandler(s, m, tomorrow, message.EventClick)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>确实以后不用修改 <code>setMsgHandler</code> 了，但是每次，还需要加两行。比如加个 <code>后天课表</code>功能，我们需要破坏 <code>Serve</code> 函数，加一行日期为后天、消息类型为<code>文本(msgTypeText)</code>的函数调用，再加一行日期为后天，消息类型为<code>点击(msgTypeText)</code>的函数调用。</p>
<p>这么多行长得相似的，重复了！</p>
<p>怎么优化？！</p>
<p>最简单的，数组！</p>
<p>Show your the code.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 微信课表查询接口支持的天数，可跨天添加</span></span><br><span class="line"><span class="keyword">var</span> supportDays = []dayOffset&#123;today, tomorrow&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, supportDay := <span class="keyword">range</span> supportDays &#123;</span><br><span class="line">		setMsgHandler(s, m, supportDay, message.MsgTypeText) <span class="comment">// 发消息触发</span></span><br><span class="line">		setMsgHandler(s, m, supportDay, message.EventClick)  <span class="comment">// 点击触发</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>以后再要删改支持查询的天数，只要删改常量，改一下 <code>String()</code> 接口，再把需要支持的天数放到 <code>supportDays</code> 切片（数组）里就好。</p>
<h2 id="七、再来点性能优化？"><a href="#七、再来点性能优化？" class="headerlink" title="七、再来点性能优化？"></a>七、再来点性能优化？</h2><p>这部分的优化，是 Atom 提出的建议，涉及一点项目细节，但读者应该能理解。  </p>
<p>我们关注 <code>setMsgHandler</code> 中的一小段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">scheduleString := m.generateScheduleMessageByOffset(msg.GetUserID(), offset)</span><br><span class="line"><span class="keyword">var</span> messageReply <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> msg.GetUserID() == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">messageReply = unBind</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">messageReply = scheduleString</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(messageReply)&#125;</span><br></pre></td></tr></table></figure>

<p>我来解读一下，第一行是调用了获取课表字符串的接口，这个接口是请求上游服务器的，是<strong>本模块最耗时的操作</strong>。  </p>
<p>但是，当 <code>userID</code> 为空时，并不会用到课表信息，白请求了一次网络。所以我们调用一下查询课表和判断 <code>userID</code> 是否为空的顺序。  </p>
<p>于是整个代码就成了这样：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMsgHandler</span><span class="params">(s *server.Server, m *module, offset dayOffset, msgType message.MsgType)</span></span> &#123;</span><br><span class="line">	msgHandleFunc := <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> messageReply <span class="keyword">string</span></span><br><span class="line">		userID := msg.GetUserID()</span><br><span class="line">		<span class="keyword">if</span> userID == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			messageReply = <span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当 userID 不为空时，才发起网络请求</span></span><br><span class="line">			messageReply = m.generateScheduleMessageByOffset(userID, offset)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(messageReply)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(msgType), offset.String(), server.KeywordTypeEqual, <span class="number">1</span>, msgHandleFunc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="八、再加点细节？"><a href="#八、再加点细节？" class="headerlink" title="八、再加点细节？"></a>八、再加点细节？</h2><p>这个时候，Eson 又说，你的 <code>setMsgHandler</code> ，关于 <code>userID</code> 的内容，足足占了四行，还有 <code>if</code> ，能不能优化一下？</p>
<p>？？？</p>
<p>我们先来分析一下，我特地声明了一个 <code>userID</code> 变量，是因为 <code>userID</code> 在「判空」和「课表查询」的时候都用到了。与其调用两次函数，不如调用一次然后保存。</p>
<p>这怎么优化？</p>
<p>Eson 说，或许能利用被调用函数抛出 <code>error</code>？</p>
<p>懂了，瞬间懂了。</p>
<p>光速改了，贴代码。还是贴图吧，Goland 的代码高亮比较阳间。</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211103145522461.png" alt="image-20211103145522461"></p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211103145610548.png" alt="image-20211103145610548"></p>
<p>用 <code>generateScheduleMessageByOffset</code> 处理空 ID 确实是优雅的，这样能保证它再次被别人调用的时候，被调皮小子传了空 ID ，能返回错误。</p>
<h2 id="九、去除同步依赖"><a href="#九、去除同步依赖" class="headerlink" title="九、去除同步依赖"></a>九、去除同步依赖</h2><p>现在的代码还是有一点相互依赖存在的，如果后面的维护者没注意到要同时更新 <code>supportDays</code> 数组和 <code>String</code> 函数内部的 map 中的触发词，会导致某天的菜单为空。能通过编译，运行却可能会出问题。</p>
<p>本来打算的一个实现方式是，在运行时检查所有的触发词是否缺失，如果缺了报 <code>Fatal</code>。因为目前对项目不了解，以为只有当新项目跑起来了，旧项目才会终止（有点像CI那味道，错了就不给部署，我的想法）。我的初衷是，把一切需要约定俗成的东西，强制由编译器检查，把错误扼杀在摇篮里。既然原作者希望后来的开发者遵守该规则，甚至是一定要遵守的，那么，为什么不直接用手段强制检查呢？哪天有个开发者没遵守，程序不就直接崩了？</p>
<p>经 Atom 提醒，如果新项目启动不了，旧项目依然会终止，目前社团部署策略不存在我假想的那种情况。</p>
<p>我仍然觉得，我的重构是有意义的。之前的代码，要改一堆函数，你只能靠后面开发者优秀的素质来支持项目的健壮性，哪个人漏改一个地方，项目就崩了。或者说，项目全是隐患。</p>
<p>可读性、易于拓展、健壮性，是我最关注的地方。然后再最大程度兼顾直观性。</p>
<h2 id="十、最后重构后的效果"><a href="#十、最后重构后的效果" class="headerlink" title="十、最后重构后的效果"></a>十、最后重构后的效果</h2><p>累了，我重构我乐意。不解释了，这次代码的改动比较小，主要把 <code>String</code> 接口换成了 <code>map</code>，其他函数略微改动了一下。愿意看我代码的人，不需要我解释；不愿意理解你的人，你解释再多，只有挨骂。我选择回避，专注做自己认为有意义的事。对我有想法的人，不在我的社交范围内。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> dayOffset <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 天数常量偏移和 uint 数字一一对应</span></span><br><span class="line">	today    dayOffset = <span class="number">0</span></span><br><span class="line">	tomorrow dayOffset = <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微信课表查询接口支持的天数，可跨天添加, 右侧的中文是微信菜单和文字消息的触发词</span></span><br><span class="line"><span class="keyword">var</span> supportDays = <span class="keyword">map</span>[dayOffset]<span class="keyword">string</span>&#123;</span><br><span class="line">	today:    <span class="string">&quot;今日课表&quot;</span>,</span><br><span class="line">	tomorrow: <span class="string">&quot;明日课表&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *module)</span> <span class="title">Serve</span><span class="params">(s *server.Server)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, err := m.cron.AddFunc(<span class="string">&quot;5 0 * * *&quot;</span>, m.updateTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	m.cron.Start()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 依次取出支持的查询天数和对应的查询触发词</span></span><br><span class="line">	<span class="keyword">for</span> supportDay, trigger := <span class="keyword">range</span> supportDays &#123;</span><br><span class="line">		setMsgHandler(s, m, supportDay, trigger, message.MsgTypeText) <span class="comment">// 发消息触发</span></span><br><span class="line">		setMsgHandler(s, m, supportDay, trigger, message.EventClick)  <span class="comment">// 点击触发</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setMsgHandler</span><span class="params">(s *server.Server, m *module, offset dayOffset, trigger <span class="keyword">string</span>, msgType message.MsgType)</span></span> &#123;</span><br><span class="line">	msgHandleFunc := <span class="function"><span class="keyword">func</span><span class="params">(msg *server.Message)</span> *<span class="title">message</span>.<span class="title">Reply</span></span> &#123;</span><br><span class="line">		msgReply, err := m.generateScheduleMessageByOffset(msg.GetUserID(), offset)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			msgReply = <span class="string">&quot;小助手无法获得您的绑定信息呢，请确认微信绑定情况，如有疑问加入杭电助手答疑群咨询哦~&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;message.Reply&#123;MsgType: message.MsgTypeText, MsgData: message.NewText(msgReply)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.MessageHandler.SetMsgHandlerRouter(<span class="keyword">string</span>(msgType), trigger, server.KeywordTypeEqual, <span class="number">1</span>, msgHandleFunc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="10-1-简单总结一下"><a href="#10-1-简单总结一下" class="headerlink" title="10.1 简单总结一下"></a>10.1 简单总结一下</h3><p>之前想要添加新的支持的课程查询天数，要改一堆东西，各种变量和函数，极容易出错。</p>
<p><strong>现在新建个日期偏移常量，和其对应的中文一起加到 map 就能实现支持任意正向天数的课表查询</strong>。除非要改内部实现，否则完全不用改动其他地方的代码。</p>
<h2 id="十一、最后再说一句"><a href="#十一、最后再说一句" class="headerlink" title="十一、最后再说一句"></a>十一、最后再说一句</h2><p>优雅啊，哥哥！</p>
]]></content>
      <tags>
        <tag>重构</tag>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象思想入门</title>
    <url>/2021/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="一、形象解释什么是面向对象"><a href="#一、形象解释什么是面向对象" class="headerlink" title="一、形象解释什么是面向对象"></a>一、形象解释什么是面向对象</h2><h3 id="1-1-小例子"><a href="#1-1-小例子" class="headerlink" title="1.1 小例子"></a>1.1 小例子</h3><p>先来个例子，简单了解一下面向过程和面向对象的区别。</p>
<blockquote>
<p>有一天你想吃鱼香肉丝了，怎么办呢？你有两个选择：<br>1、自己买材料，肉，鱼香肉丝调料，蒜苔，胡萝卜等等然后切菜切肉，开炒，盛到盘子里。<br>2、去饭店，张开嘴：老板！来一份鱼香肉丝！<br>看出来区别了吗？1是面向过程，2是面向对象。</p>
</blockquote>
<span id="more"></span>

<p><em>文章来源：<a href="https://www.jianshu.com/p/7a5b0043b035">什么是面向对象（OOP） - 简书</a></em></p>
<p><em>本文也就这段话是复制的了，本来想做个资源帖的收集，写着写着发现，还是自己写的东西有趣，干脆就不参考了。<br>至于那些非常专业的文章，大家在看了我的文章后，建立了对面向对象思想的理解，也就看得懂其他文章了，自行查阅就好。</em></p>
<p>狭义地理解，面向过程就是，<strong>以过程为中心</strong>，就像做数学题那样，定义了解题的一个个步骤。<br>面向对象就是，抽象出一个个的模型，已经预定义了这个类型有哪些属性，能做些什么，直接调用就好。 </p>
<h3 id="1-2-面向对象再解释"><a href="#1-2-面向对象再解释" class="headerlink" title="1.2 面向对象再解释"></a>1.2 面向对象再解释</h3><p>上面我们通过一个例子感性得理解了面向对象的整体，下面我们继续举例，带大家理解面向对象的细节。  </p>
<p>直接来个实际的例子，例如，我们要实现一个查询学生电话号码的接口。  </p>
<p><strong>面向过程的实现方法：</strong><br>写个 <code>getStudentInfo</code> 函数，形参是学生的唯一标识符（如学号）。<br>先不考虑数据库，那么我们需要维护一个学生信息的数组，然后一个个比对。  </p>
<p>如果我们又要实现，查询学生寝室号、辅导员，又要再写两个函数吗？而且这些函数的形参，全是学生ID。  </p>
<p>有没有更好的解决方案呢？</p>
<p>这时候你可能会质疑，我学过 C 啊，你讲的这玩意，压根不用定义函数啊？  </p>
<p>我直接进行一个结构体的定义，一个 <code>Student</code> 结构体，然后把学号、姓名、电话、辅导员信息都塞里面，<br>想查询信息的时候，只要用 <code>student.name</code> 就能获取到姓名了。  </p>
<p>其实，这便是一种非常简单的面向对象的思想。前面讲过，面向对象，在我的理解中，最浅层的，<br>就是把一些属性和能做什么聚在一起，形成一个类。而 C语言 的结构体，就是做到了属性的聚合。  </p>
<p>继续给需求，如果主人又来任务了，这时候给了个，「上课签到记录」的接口，怎么办？<br>结构体成员变量实现这个功能吧？</p>
<p>一个声音浮现在脑海：用函数啊！直接定义一个签到函数！</p>
<p>可是函数，它就，不优雅了啊，它是面向过程！</p>
<p>那么，我们既然已经把属性塞到结构体里面了，采用 <code>变量.属性名</code> 的方式获取。<br>我们可不可以，把函数也塞到结构体里面呢？采用 <code>变量.函数名</code> 的方式获取？</p>
<p>大聪明鬼，这就是 Go 语言面向对象的简单实现了！！！</p>
<p>把属性和行为塞（封装）到结构体里面之后，和之前的面向过程有什么不一样？</p>
<p>之前的函数调用，学生属于形参，是传进去的。 <code>getInfo(user)</code> ，<br>而现在，学生是调用方，是主体， <code>user.GetInfo()</code>。</p>
<p>换句话说，之前的函数调用， 操作的是外部的数据信息。而现在，变量（属性）操作（方法）<br>成为了类型的一部分，是固有的。一旦这个类型建立了，那它对应的变量什么的，也都直接附带上了。<br>同时，利用对象调用方法，更像是一种「操作」，什么叫操作？就是，我这个对象，里面有些数据，<br>通过调用某个方法，修改了对象内的一些信息，「操作」了一下。就这么先这么狭义理解。</p>
<p>有个小细节需要注意，当函数和对象结合的时候，它就不叫函数了，叫「方法」。任何语言都是如此。  </p>
<p>不同语言面向对象的实现方法都不一样，大部分面向对象的语言，都是用 <code>class</code> 关键字实现的，<br>Go 语言的实现比较奇葩，是用 <code>Struct</code> 和 <code>receiver</code> 来结合实现的，它不是纯粹的面向对象语言。  </p>
<p>所以在初学面向对象思想的时候，不建议一开始就拿 Go 语言学习面向对象，容易走火入魔。<br>比较建议看看 <code>C++</code> 或 <code>Java</code> 的面向对象的实现。不过话说回来，虽然 Go 的面向对象实现有点显得歪门邪道，<br>但是，当它和 Go 的接口结合起来的时候，一切就都会变得非常有趣。<br>我更愿意称 Go 语言的面向对象是灵活的面向对象。</p>
<h2 id="面向对象概念解释"><a href="#面向对象概念解释" class="headerlink" title="面向对象概念解释"></a>面向对象概念解释</h2><p>首先是 <code>类</code> 的概念。类，你可以理解为，类型的意思。<br>或者说，他们是同一类的，他们有相似的行为（函数），相似的特征（属性），那他们就是一类。<br>比如，人类，动物类，学生类。  </p>
<p>然后是 <code>对象</code> 的概念，这个对象不是那种，冬天了可以抱抱的对象。是 <code>类</code> 的 <code>实例</code>。<br>类，概括出了同一种类型的事物，对象，就是这一类事物中，具体的某个个体。<br>比如，<code>人类</code> 是个 <code>类</code>，张三就是个对象，或者说 <code>实例</code>。利用类建立对象的过程，就叫 <code>实例化</code>。</p>
<p>然后是 <code>继承</code>。我不说啥意思，就举例子，你自己体会。哺乳动物类继承动物类，人类继承哺乳动物类，<br>男人类继承人类，爸爸类继承男人类。</p>
<p>A类 <code>继承</code> B类，表明，A类拥有B类的所有属性（特征）和方法（行为、能做的事）。并且自己可以加些新的属性和方法。<br>比如，女人类拥有人类的一切属性，又能做任何人能做的事，她又可以有些特殊的属性或方法。<br>而程序员类不是继承了男人类或女人类的。被继承的类叫 <code>父类</code>，另外一个叫 <code>子类</code>。</p>
<p>再解释一下什么叫 <code>封装</code>。先贴个专业解释：</p>
<blockquote>
<p>通过对象隐藏程序的具体实现细节，将数据与操作包装在一起，<br>对象与对象之间通过消息传递机制实现互相通信（方法调用），<br>具体的表现就是通过提供访问接口实现消息的传入传出。</p>
</blockquote>
<p>麻了吧？</p>
<p>其实前面讲的那些，把属性和方法放在一起，就是封装的一部分。也就是被引用的内容中提到的<br>「将数据和操作包装在一起」。数据就是属性，操作就是方法、行为。</p>
<p>什么叫隐藏实现细节呢？简单说两点：</p>
<p>第一，C语言的结构体，任何类型都是可以直接访问的，<br>我想让外部调用者没法直接访问某些数据怎么办？用类可以实现。<br>第二，别人写好的东西，我才不管你具体怎么实现的，我只要知道怎么用就行。<br>甚至，我只要知道哪个方法能查成绩就行，我就这么写了，<br>如果你想修改查成绩的内部实现，和我无关，因为接口已经定死了。</p>
<p>其实这个和函数封装差不多。</p>
<p>最后解释一下，<code>多态</code>。</p>
<p>还是举例子吧，前面讲到，我想查询学生的基本信息，写了个方法。</p>
<p>现在，我又想查询老师的基本信息了，再写个方法？</p>
<p>那这样的话，要针对不同的类型写不同的方法，但他们实际执行的操作差不多啊？<br>而且，我如果想用一个函数就能查询老师或学生的信息，要写一堆 <code>if</code> 吗？</p>
<p>能优雅一点吗？</p>
<p>面向对象，类似的属性和操作，都能封装。他们都叫「查询某个人的基本信息」。</p>
<p>其实，我们可以定义一个「学校师生」父类，「学生类」和「教职工」类分别继承它。<br>「学校师生」类可以定义一个「查询信息」方法，然后另外两个类 <code>重写</code> 这个方法。<br>即，父类有个 <code>getInfo()</code> 的方法，两个子类也各有一个 <code>getInfo()</code> 的同名方法。</p>
<p>这么做有什么好处？怎么还不讲多态？？？</p>
<p>多态有很多种，这里讲一种。比如，你可以定义一个基类的变量（指针），它是可以引用（指向）<br>所有父类的。换句话说，你可以定义一个「学校师生」类的变量，<br>然后查询信息的时候，直接调用 <code>父类.getInfo()</code><br>无论你是通过「学生类」还是「教职工」类的对象调用的这个方法，<br>编译器都能找到对应的方法，即，它知道该调用哪个查询信息的方法，即，<br>如果是学生调用这个方法，就查询学生信息，如果是老师就查询老师信息。非常的阳间。</p>
<p>未完待续。。。</p>
]]></content>
  </entry>
  <entry>
    <title>一个简单的提交统计工具</title>
    <url>/2021/10/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%8F%90%E4%BA%A4%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="项目由来"><a href="#项目由来" class="headerlink" title="项目由来"></a>项目由来</h2><p>最近在做一些群内的人员管理工作，经常要下发表格，筛选出没提交的人。<br>众所周知，懒是第一生产力，于是开发了一个可以根据人员信息表与实际提交信息，直接计算出未提交名单的工具。</p>
<p>目前只做了桌面命令行极简版。仓库地址：<a href="https://github.com/aFlyBird0/submit_tools">aFlyBird0/submit_tools: 看看谁还没提交！！！</a></p>
<h3 id="思路介绍"><a href="#思路介绍" class="headerlink" title="思路介绍"></a>思路介绍</h3><p>先考虑最简单的情况：如果所有人的信息，仅提供姓名。</p>
<p>那么只要先维护一个姓名列表，然后使用某种途径获取已经提交了人的列表。遍历姓名列表，一个个看该姓名是否出现在了提交列表中即可。</p>
<p>稍微复杂一些：提交列表不一定是规整的数组，可能来源于网页表格；也可能来源于QQ的投票统计，是OCR的结果。即，拥有许多杂乱的内容。这时候可以退而求其次，把提交信息统一转化成一个多行字符串，将列表的对应查询变成了 <code>strings.Contains()</code> 操作。</p>
<span id="more"></span>

<h3 id="目前版本"><a href="#目前版本" class="headerlink" title="目前版本"></a>目前版本</h3><p>再丰富些：添加别名功能。比如，可能我们需要判断谁不在 Github 组织里，或者说收集表上只有大家的手机号而没有姓名字段，所有数据结构可以这样设计：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span>   <span class="comment">//标准名</span></span><br><span class="line">	Alias  []<span class="keyword">string</span> <span class="comment">//别名，可以是邮箱、QQ号等</span></span><br><span class="line">	Submit <span class="keyword">bool</span>     <span class="comment">// 是否已提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>维护一张信息表，使用 csv 结构，一行是一个人员信息。其中第一列是姓名，即标准名。后面的列数量任意，都是能唯一标识该人的 ID ，如 QQ、电话、邮箱。</p>
<p>只要标准名或别名中的任何一个字段命中了提交信息（字符串），就认为该人已提交。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><p>这样有个 bug，如果一个人叫「张三」、另一个叫「张三丰」，那么只要后者提交了，前者会被误判为已提交。<br>适当规避这个 bug 的方式是，使用较长的唯一 id。</p>
<h3 id="未来可能的改进思路"><a href="#未来可能的改进思路" class="headerlink" title="未来可能的改进思路"></a>未来可能的改进思路</h3><p>和 Kevin 大佬聊了之后，有了以下几个改进思路：</p>
<ol>
<li>原来的提交信息只是纯文本字符串。可以把这个改成一个接口，对于不同的类型，如 csv、在线表格，实现不同的命中方法。其他的，从给出的提交信息中，抽取可以被当作 ID 的字段也可以封装为接口。</li>
<li>把提交信息由原来的一大串文本改为，只接受一行一行的提交。每行提交只能被命中一次，若被命中多次，提示用户可能存在歧义。</li>
<li>利用 qq_bot 等工具收集人员信息。之前收集群所有人的备注，OCR 可能会出问题，如果能直接调 QQ 接口更好。</li>
</ol>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Golang之T与*T方法集及receiver</title>
    <url>/2021/10/%E6%B5%85%E6%9E%90Golang%E4%B9%8BT%E4%B8%8ET%E6%96%B9%E6%B3%95%E9%9B%86%E5%8F%8Areceiver/</url>
    <content><![CDATA[<p>到今天为止，差不多正式学 Go 一个月。一直觉得 receiver 的 T 和 *T 的方法集云里雾里，好在通过多次查阅资料和代码实践，终于在表象方面掌握了七七八八。本文涉及 T 与 *T 方法集的关系，编译器自动解引用与取地址，T 与 *T 接口实现等。不一定全对，希望大佬指正错误。本文废话很多，一个概念翻来覆去讲了很多遍，但也是这样，才能使读者从各个角度印证自己的想法是否和我的思想一致，太多博客讲得单一了容易有理解偏差。</p>
<span id="more"></span>

<h2 id="一、什么是方法集"><a href="#一、什么是方法集" class="headerlink" title="一、什么是方法集"></a>一、什么是方法集</h2><p>首先弄明白什么是方法集，之前看帖子把自己看迷糊了就是因为，把方法集的引出对象搞错了。方法集的主语是变量。也就是说，如果有个变量类型是 T，那么我们可以说，T有什么什么方法集，T的方法集是什么。</p>
<p>再做个简单的阅读理解：方法集就是，方法的集合。T拥有的方法集是所有 receiver 为 T 的方法的集合，也就是说，T 可以调用所有 receiver 为 T 的方法。更进一步，如果这些 receiver 为 T 的方法中的某几个，实现了某个接口需要实现的方法，那么，T 也实现了该接口。</p>
<p>类似的，*T 的方法集，是所有 receiver 为 T 与 *T 的方法的集合，也就是说，*T 变量可以调用 receiver 为 T 或 *T 的方法（至于为什么，后面会讲到）。有的文章会写到， *T 的方法集包含了 T 的方法集，或者说，T 的方法集是 *T 的子集。意思就是，*T 能调用 receiver 为 T 和 *T 的方法，而 T 只能调用 receiver 为 T 的方法。</p>
<h2 id="二、什么时候能通过方法调用改变-receiver-的值"><a href="#二、什么时候能通过方法调用改变-receiver-的值" class="headerlink" title="二、什么时候能通过方法调用改变 receiver 的值"></a>二、什么时候能通过方法调用改变 receiver 的值</h2><p>方法能不能改 receiver 的值，只取决于方法定义的时候，接收者是不是指针。如果接收者是指针，方法被调用后，改变的值是生效的。详细看图。</p>
<p><code>ChangeName</code> 方法的 receiver 是指针，所以无论是 值类型（以后值类型都用 T 表示），还是指针类型（以后指针类型都用 *T 表示）调用 <code>ChangeName</code> 方法，改动都是生效的。</p>
<p>同理，如果 receiver 是 T，那么无论调用者是 T 还是 *T ，改动都不生效</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/%5BQJUH5B6I~%60~X96GWO%5D@IP3.jpg" alt="img"></p>
<h2 id="三、T-与-T-作为-receiver-的调用法则"><a href="#三、T-与-T-作为-receiver-的调用法则" class="headerlink" title="三、T 与 *T 作为 receiver 的调用法则"></a>三、T 与 *T 作为 receiver 的调用法则</h2><p>现在我们抛弃编译器的语法糖，即把编译器自动取地址的功能抛弃</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/LE22YTJCV4%5B%5BW058%60%5B31ZQL.jpg" alt="img"></p>
<p>说人话就是，如果我定义了一个 T 变量，那么它只能调用 (t T)func() 的方法，也就是只能调用 receiver 为 T 的方法</p>
<p>如果定义了一个 *T 变量，那么它能同时调用 (t <em>T)func() 和 (t T)func() 的方法。也就是说，</em>T 类型的方法集包含了 T 和 *T 所有的方法集</p>
<p>那为什么 T 有时候能调用 (t *T)func() 的方法呢？因为，如果 t 可取址，编译器会自动加上&amp;，所以大部分时候，无论接收者是 T 还是 *T，都能互相调</p>
<p>同样，我猜测，*T 能调用 (t T)func() 的，是编译器自动解引用的功劳。类似于，结构体指针引用成员变量，不需要这样：(*s).name， 只需要 s.name，编译器会自动解引用。</p>
<p>无论如何 *T 一定能调用 (t T)func() 的，因为，解引用永远不会失败。但是取址不一定每次都成功。（例如字面量不能取址）</p>
<p>如果上面没看懂，可以看图：</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211006010905729.png" alt="image-20211006010905729"></p>
<p><strong>小结论：</strong>所以其实在一般情况下，**无论 receiver 是 T 还是 <em>T，无论变量是 T 还是 <em>T ，都是能两两互相调用的。</em></em></p>
<p>理由如下：</p>
<p>① T 调用 T，*T 调用 *T，理所当然。</p>
<p>②*T 调用 T 时，变量属于指针，receiver 要求是值，那么编译器会自动把指针解引用成值，一定是成功的。</p>
<p>③T 调用 *T 时，变量是值，receiver 要求是指针，<strong>若变量可取址</strong>，编译器会自动取个地址把值变成指针，依旧能调用。</p>
<h2 id="四、不同视角看待方法集与-receiver"><a href="#四、不同视角看待方法集与-receiver" class="headerlink" title="四、不同视角看待方法集与 receiver"></a>四、不同视角看待方法集与 receiver</h2><p>下面我们从两种视角探讨一下方法集和 receiver 的关系，巩固一下。</p>
<p>上面那部分讲的是，固定变量的类型（T或*T），来看看它能调用什么方法</p>
<p>下面那部分讲的是，固定方法的接收器的类型（T或*T），来看看它能被什么变量调用</p>
<p>其实内容和上面讲的一样，但是主语不一样，能把橙字全部看懂，应该就算绕过来了。</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211006010854888.png" alt="image-20211006010854888"></p>
<h2 id="五、receiver-的-T、-T-与实现接口的关系"><a href="#五、receiver-的-T、-T-与实现接口的关系" class="headerlink" title="五、receiver 的 T、*T 与实现接口的关系"></a>五、receiver 的 T、*T 与实现接口的关系</h2><p>先明确一点，什么叫实现了接口：如果某个类型，实现了某个接口需要实现的所有方法，那么它就实现了这个接口。</p>
<p>这是个废话，应用在本文，我们应当关注：</p>
<ul>
<li>T类型实现了什么方法，*T类型实现了什么方法？——见实例</li>
<li>有哪些方法是隐含实现的？——见面三张图</li>
<li><strong>实现接口与前面讲的谁能调用谁的关系是什么：T变量能调用方法A，那么T就实现了方法A</strong></li>
</ul>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211006011630363.png" alt="image-20211006011630363"></p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211006011635989.png" alt="image-20211006011635989"></p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20211006011642911.png" alt="image-20211006011642911"></p>
<p>下面这段又都是<strong>重点</strong>：</p>
<p>前面讲到，若 receiver 是 T，那么，T 与 *T 类型的变量，都能调用该方法。换句话说，如果有个方法的 receiver 是 T，那么它其实<strong>隐含实现了 receiver 为 *T 的方法</strong>。对应上图，黄色框的函数是隐含实现的。</p>
<p>而 receiver 为 *T 的方法，只能被 *T 的类型调用。也就没有隐含实现这一说法。</p>
<p>所以导致了，虽然我们只定义了两个方法，但却生成了上图绿色字体的三个方法。</p>
<p>我们再来数一数，接口实现。 <code>myInterface</code> 需要实现 <code>ChangeName</code> 和 <code>SayName</code> 两个方法，看看橙色的箭头，刚好凑齐了两个方法，并且 receiver 都是 *T。所以 *myStruct 实现了接口。</p>
<p>而 myStruct ，值类型，只有一个 receiver 为 sayMyName 的方法，只实现了一个，也就是没有实现接口。</p>
<h2 id="六、深层次原理探讨"><a href="#六、深层次原理探讨" class="headerlink" title="六、深层次原理探讨"></a>六、深层次原理探讨</h2><p>本文全都是讲的现象，或者说以一种不确切的方式来记忆 Golang 特性的方法，结果是正确的，但是原因不一定完全准确。</p>
<p>更深层次的源码级的探讨，可以看这个视频 <a href="https://www.bilibili.com/video/BV1NK4y137PJ?spm_id_from=333.999.0.0">【Golang】T和*T的方法集是啥关系？_哔哩哔哩_bilibili</a></p>
<h2 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h2><ul>
<li><p><a href="https://juejin.cn/post/6844903831365648391">Golang研学：在用好Golang指针类型 - 掘金</a></p>
</li>
<li><p><a href="https://blog.csdn.net/e3002/article/details/109459356">Go 中关于方法的 receiver 的总结_paul的专栏-CSDN博客_go receiver</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/qiumingcheng/p/9829781.html">Go的方法集 - 邱明成 - 博客园</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/d93656cdce0a">Golang中的方法集问题 - 简书</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_34177064/article/details/88918754">goLang 之 type Method Value 和Method Expressions_weixin_34177064的博客-CSDN博客</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Golang 解析专利审查指南</title>
    <url>/2021/09/%E4%BD%BF%E7%94%A8%20Golang%20%E8%A7%A3%E6%9E%90%E4%B8%93%E5%88%A9%E5%AE%A1%E6%9F%A5%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="专利审查指南解析"><a href="#专利审查指南解析" class="headerlink" title="专利审查指南解析"></a>专利审查指南解析</h1><p>本项目代码地址：<a href="https://github.com/BirdBirdLee/parsePatentWord">BirdBirdLee/parsePatentWord: 利用 Golang 解析《专利审查指南 2020…doc》，并将标题、段落层级关系存至数据库</a></p>
<h2 id="〇、本项目的由来、意义"><a href="#〇、本项目的由来、意义" class="headerlink" title="〇、本项目的由来、意义"></a>〇、本项目的由来、意义</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><p>导师布置了个任务，提取《专利审查指南…》，做成电子书。所以第一步是把标题层级和段落内容提取到数据库里面。<br>师兄说建议用 Java 的 <code>Apache POI</code>，但我刚学了 Golang 一星期，就想用 Golang 做！！！死磕~~~（其实中间反复过两次，真的很想用 Java 或 Python 的 API！还好坚持下来了，收获了很多）</p>
<span id="more"></span>

<h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><ol>
<li>第一个真正意义上的自己的 Go 项目，检验、巩固了前几天的学习</li>
<li>第一次这么认真看源码，因为没有文档？？！极大锻炼了自己看源码的能力，还挺有趣？</li>
<li>和室友拥有了一次愉快的半夜一起写代码的奇妙而又愉快的体验。他看我在弄，来了兴趣，现学 C# 和我并行尝试。中间不少思路我们都想到一块了，比如发现文档没有标题格式全是正文，思考大纲转标题，然后又都决定找框架的「大纲」接口</li>
<li>提前一星期完成了老师的任务，后面一星期可以专心学 Go 了。</li>
<li>利用这次项目，对 vim 比以前更习惯了一点，总算「存活」下来了。</li>
</ol>
<h2 id="一、本项目内容"><a href="#一、本项目内容" class="headerlink" title="一、本项目内容"></a>一、本项目内容</h2><p>项目大背景：把《专利审查指南…》做成网页版的电子书，加入高级搜索等功能。<br>本项目工作：提取《专利审查…》内容，抽取标题层级和段落内容，存入数据库中。<br>项目进度：</p>
<ul>
<li>2021年9月11日 3点52分 目前已完成标题层级与文档内容抽取为 <code>Golang Slice</code> 功能。</li>
<li>2021年9月13日：标题与段落内容加上层级关系；数据入库</li>
<li>2021年9月15日：完成了从数据库中查询目录，生成树结构传给前端，以及查询文章内容。（在另一个项目中）</li>
</ul>
<h2 id="二、抽取过程概述"><a href="#二、抽取过程概述" class="headerlink" title="二、抽取过程概述"></a>二、抽取过程概述</h2><h3 id="2-1-按段落与大纲初步抽取"><a href="#2-1-按段落与大纲初步抽取" class="headerlink" title="2.1 按段落与大纲初步抽取"></a>2.1 按段落与大纲初步抽取</h3><p>阅读 <code>gooxml</code> 源码，按段落抽取 Word 文档，每段带有大纲级别。该步骤得到的内容格式如下：</p>
<p><img src="https://bird-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210915223953307.png" alt="image-20210915223953307"></p>
<p>其中，<code>4</code> 代表4级目录，<code>0</code> 代表文本内容</p>
<h3 id="2-2-合并近邻的同大纲内容"><a href="#2-2-合并近邻的同大纲内容" class="headerlink" title="2.2 合并近邻的同大纲内容"></a>2.2 合并近邻的同大纲内容</h3><p>同一目录下可能有多个段落，但向前端返回的文本，应该是一整段，所以合并紧邻的同大纲内容。</p>
<h3 id="2-3-将层级目录与文本内容存至数据库中"><a href="#2-3-将层级目录与文本内容存至数据库中" class="headerlink" title="2.3 将层级目录与文本内容存至数据库中"></a>2.3 将层级目录与文本内容存至数据库中</h3><p>** 这步为本项目的难点 **<br>源码见 <code>/build/build.go</code><br>上一步获得的内容是这样的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="string">这是一级标题</span> <span class="string">a</span></span><br><span class="line"><span class="number">1</span>   <span class="string">这是一级标题</span> <span class="string">b</span></span><br><span class="line"><span class="number">2</span> <span class="string">这是一级标题</span> <span class="string">b</span> <span class="string">下的二级标题</span> <span class="string">c</span></span><br><span class="line"><span class="number">3</span> <span class="string">这是二级标题</span> <span class="string">c</span> <span class="string">下的三级标题</span> <span class="string">d</span></span><br><span class="line"><span class="number">0</span> <span class="string">这是三级标题下的文本</span> <span class="string">e</span></span><br><span class="line"><span class="number">2</span> <span class="string">这是一级标题</span> <span class="string">a</span> <span class="string">下的二级标题</span> <span class="string">f</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>难点在于：<strong>既要在数据库中指明段落文本属于哪个标题（目录），又要指明每个标题的父标题是什么</strong><br>这里用到了 <strong>栈</strong>，来保存最近的一个标题在数据库中的 <code>id</code> 以及 当前的最深的大纲级别 <code>maxLvl</code>（代码中是 <code>lastLvl</code>）<br>逐个遍历第二步得到的带有大纲级别的段落：</p>
<ul>
<li>如果当前内容是文本（大纲级别是0），之前链接此文本内容到栈顶的标题。因为是文本内容一定附属在最近的标题下。</li>
<li>如果是当前内容是标题（大纲级别大于0）<ul>
<li>如果当前内容的大纲级别大于 <code>maxLvl</code> ，就说明目录变深了，压栈，<code>maxLvl</code> + 1，并将当前标题的父标题指向原来栈顶的 <code>id</code></li>
<li>如果相同，出栈，保证栈内不存在同级大纲。这样出栈后，当前栈顶元素一定是当前内容的父标题。 <code>maxLvl</code>不变，标题父目录指向出栈后的 <code>id</code>。</li>
<li>如果小于。出栈多次。因为变深只能一次深一级，如从二级目录变成三级目录，而变浅可以直接从三级目录变成一级目录。计算变浅的差值，决定 <code>pop</code> 的次数，以及 <code>maxLvl</code> 减少的层级即可。</li>
</ul>
</li>
</ul>
<h2 id="三、开发问题与解决方案记录"><a href="#三、开发问题与解决方案记录" class="headerlink" title="三、开发问题与解决方案记录"></a>三、开发问题与解决方案记录</h2><h3 id="1-文件相对绝对路径"><a href="#1-文件相对绝对路径" class="headerlink" title="1.文件相对绝对路径"></a>1.文件相对绝对路径</h3><p>Go 的环境路径和项目路径不一致，所以要获取代码文件所在的路径，自己写了个工具类，即 <code>/util/fileUtil.go</code> 的 <code>GetRunPath()</code></p>
<h3 id="2-gooxml-document-不支持-doc"><a href="#2-gooxml-document-不支持-doc" class="headerlink" title="2. gooxml document 不支持 doc"></a>2. gooxml document 不支持 doc</h3><p>doc 转存成 docx</p>
<h3 id="3-gooxml-和-unidoc-unioffice-弃用"><a href="#3-gooxml-和-unidoc-unioffice-弃用" class="headerlink" title="3. gooxml 和 unidoc/unioffice 弃用"></a>3. gooxml 和 unidoc/unioffice 弃用</h3><p>gooxml 太旧了，文档也 404<br>unioffice 应该是基于 gooxml 写的，但是要授权，只能免费用 14 天<br>所以都弃用，但是真就没办法了吗？</p>
<h3 id="4-切换解析-word-方法"><a href="#4-切换解析-word-方法" class="headerlink" title="4. 切换解析 word 方法"></a>4. 切换解析 word 方法</h3><p>受某大佬启发，先将 word 转成 html 的形式，再读取 html，原因如下：<br>我要实现的目标是读取 word，所以可以转换成等效格式，再提取。如果是编辑 word，那可能要直接操作 word 了<br>之所以选择 html ，是因为我之前对爬虫比较熟，用 xpath 有信心。分析 html 源码后，确定能获取各元素属性</p>
<h3 id="4-如何解析标题"><a href="#4-如何解析标题" class="headerlink" title="4. 如何解析标题"></a>4. 如何解析标题</h3><p><code>mso-outline-level</code> 属性，揭示了大纲级别，<code>1</code> 为「第一部分 初步审查」，以此类推</p>
<h3 id="5-如何解析文本（段落）"><a href="#5-如何解析文本（段落）" class="headerlink" title="5. 如何解析文本（段落）"></a>5. 如何解析文本（段落）</h3><p>转化成的 html ，一段为一个 <code>div</code>， 同一标题下的多段没有共同的 <code>div</code>，所以只能一段一段提取。<br>目前拟采用 <code>mso-char-indent-count:2.0</code>，因为每段前都有缩进。</p>
<h3 id="6-编码与文件转换问题"><a href="#6-编码与文件转换问题" class="headerlink" title="6. 编码与文件转换问题"></a>6. 编码与文件转换问题</h3><p>先把 doc 转 docx，再另存为 html，再用 vscode 打开（编码 GBK），然后保存成 UTF-8</p>
<h3 id="7-htmlQuery-获取-html-node-的字符串"><a href="#7-htmlQuery-获取-html-node-的字符串" class="headerlink" title="7. htmlQuery 获取 html node 的字符串"></a>7. htmlQuery 获取 html node 的字符串</h3><p>查看源代码，引用 <code>Data</code> 属性就行<br>注：因为 Word 转 html 后有很多格式错乱(例如左侧的「细则」会整段混入到右侧的文本中），导致虽然能识别大部分文档，但是会有很多乱七八糟的东西，所以还是决定再试试 gooxml</p>
<h3 id="8-利用-gooxml-document-设置-word-样式"><a href="#8-利用-gooxml-document-设置-word-样式" class="headerlink" title="8. 利用 gooxml/document 设置 word 样式"></a>8. 利用 gooxml/document 设置 word 样式</h3><p><a href="https://github.com/carmel/gooxml/blob/master/_examples/document/simple/main.go">gooxml/main.go at master · carmel/gooxml</a><br>利用 para.SetStyle() 属性</p>
<h3 id="9-如何利用-gooxml-document-获取段落属性"><a href="#9-如何利用-gooxml-document-获取段落属性" class="headerlink" title="9. 如何利用 gooxml/document 获取段落属性"></a>9. 如何利用 gooxml/document 获取段落属性</h3><p>这里没有文档，是个难点，只能肝源码<br>先看看 <code>(p Paragraph) SetStyle(s string)</code> 的函数定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Paragraph)</span> <span class="title">SetStyle</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    p.ensurePPr()</span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        p.x.PPr.PStyle = <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.x.PPr.PStyle = wml.NewCT_String()</span><br><span class="line">        p.x.PPr.PStyle.ValAttr = s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以得知，关键样式属性在于 <code>Paragraph.p.x.PPr.PStyle.ValAttr</code>, 但这是私有属性。<br>继续看 <code>Paragraph</code> 所在的 <code>paragraph.go</code> 文件，找到了 <code>(p Paragraph) Style() string</code> 函数</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Paragraph)</span> <span class="title">Style</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.x.PPr != <span class="literal">nil</span> &amp;&amp; p.x.PPr.PStyle != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.x.PPr.PStyle.ValAttr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Bingo！</p>
<h3 id="10-《审查指南…》中，没有「标题」样式，全是正文"><a href="#10-《审查指南…》中，没有「标题」样式，全是正文" class="headerlink" title="10. 《审查指南…》中，没有「标题」样式，全是正文"></a>10. 《审查指南…》中，没有「标题」样式，全是正文</h3><p>正常的格式应该是 <code>Heading1</code> 这种（经由 <code>/try/parseTry.go</code> 中的 <code>TestNewDocGooxml</code> 测试，确保正确）<br>但是，获取了同一个 <code>style</code>（即 <code>x.PPr.PStyle.ValAttr</code>）属性，发现：<br>** 《审查指南..》中的样式，要么是空，要么是类似 <code>1</code>、<code>2</code>、<code>40</code>、<code>50</code> 这样的数字<br>并且，这些数字和大纲级别没有严格对应之处</p>
<h3 id="11-尝试用属性获取"><a href="#11-尝试用属性获取" class="headerlink" title="11. 尝试用属性获取"></a>11. 尝试用属性获取</h3><p><code>paragraph.go</code> 源码文件，有个 <code>Properties</code> 函数，或许有用</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Paragraph)</span> <span class="title">Properties</span><span class="params">()</span> <span class="title">ParagraphProperties</span></span> &#123;</span><br><span class="line">	p.ensurePPr()</span><br><span class="line">	<span class="keyword">return</span> ParagraphProperties&#123;p.d, p.x.PPr&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 <code>PragraphProperties.go</code>，得到：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ParagraphProperties are the properties for a paragraph.</span></span><br><span class="line"><span class="keyword">type</span> ParagraphProperties <span class="keyword">struct</span> &#123;</span><br><span class="line">	d *Document</span><br><span class="line">	x *wml.CT_PPr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Style returns the style for a paragraph, or an empty string if it is unset.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ParagraphProperties)</span> <span class="title">Style</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> p.x.PStyle != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> p.x.PStyle.ValAttr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过测试，发现这里的 <code>style</code> 和前面那个 <code>style</code> 指向的是同一个东西，线索中断。</p>
<h3 id="12-能否通过将大纲转成标题来实现提取？"><a href="#12-能否通过将大纲转成标题来实现提取？" class="headerlink" title="12. 能否通过将大纲转成标题来实现提取？"></a>12. 能否通过将大纲转成标题来实现提取？</h3><p>《审查指南…》虽然没有标题级别，但是有严格的大纲级别，能否通过外部手段，不通过 <code>Golang</code>，先把大纲转成 <code>style</code> 的 <code>Heading</code>？</p>
<h3 id="13-找到了-gooxml-中的-「大纲属性」"><a href="#13-找到了-gooxml-中的-「大纲属性」" class="headerlink" title="13. 找到了 gooxml 中的 「大纲属性」"></a>13. 找到了 gooxml 中的 「大纲属性」</h3><p>先去看 <code>ParagraphProperties.go</code> 文件，找到类定义：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ParagraphProperties are the properties for a paragraph.</span></span><br><span class="line"><span class="keyword">type</span> ParagraphProperties <span class="keyword">struct</span> &#123;</span><br><span class="line">	d *Document</span><br><span class="line">	x *wml.CT_PPr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看看 <code>wml.CT_PPr</code> 到底是怎么定义的？<br><code>CT_PPr.go</code> 中定义了该结构体，其中有一个属性是这个：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Associated Outline Level</span></span><br><span class="line"><span class="keyword">type</span> CT_PPr <span class="keyword">struct</span> &#123;</span><br><span class="line">	...</span><br><span class="line">	OutlineLvl *CT_DecimalNumber</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看看 <code>CT_DecimalNumber</code> 是什么：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CT_DecimalNumber <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Decimal Number Value</span></span><br><span class="line">	ValAttr <span class="keyword">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是个结构体指针，里面有个 <code>int64</code><br>那么怎么获取这个属性(<code>x *wml.CT_PPr</code>)呢？回到 <code>ParagraphProperties.go</code> 中：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="comment">// X returns the inner wrapped XML type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p ParagraphProperties)</span> <span class="title">X</span><span class="params">()</span> *<span class="title">wml</span>.<span class="title">CT_PPr</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p.x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下，获取 Word 大纲级别的方式如下，这里要防止空指针：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, para := <span class="keyword">range</span> doc.Paragraphs() &#123;</span><br><span class="line">    <span class="keyword">var</span> outlineLvl <span class="keyword">int64</span></span><br><span class="line">    <span class="keyword">if</span> outlineLvlStruct := para.Properties().X().OutlineLvl; outlineLvlStruct!=<span class="literal">nil</span>&#123;</span><br><span class="line">        outlineLvl = outlineLvlStruct.ValAttr</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        outlineLvl = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="https://github.com/unidoc/unioffice">unidoc/unioffice 另外一个可以处理 office 的文档</a></li>
<li><a href="https://pkg.go.dev/github.com/baliance/gooxml#section-readme">gooxml 官方文档</a> 这个文档应该是 <code>unioffice</code> 的前身</li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>声昔-读书会-亲密关系</title>
    <url>/2021/05/%E5%A3%B0%E6%98%94-%E8%AF%BB%E4%B9%A6%E4%BC%9A-%E4%BA%B2%E5%AF%86%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><h3 id="何为亲密关系"><a href="#何为亲密关系" class="headerlink" title="何为亲密关系"></a>何为亲密关系</h3><p>本意是指不限年龄和性别的两人之间和谐、融洽的关系。但目前来说，大多数情况下指的是情侣、夫妻间的爱情。值得注意的是，心理学家认为，两个人之间存在影响与互赖，才称之为关系。所以其实并非所有情侣、婚姻间都存在亲密关系。</p>
<h3 id="选题原因"><a href="#选题原因" class="headerlink" title="选题原因"></a>选题原因</h3><ol>
<li>亲密关系的重要性</li>
<li>我在亲密关系上失败太多次，不想再有更多的人像我一样因为没做好准备，没有把握住甜美的爱情</li>
<li>本次共读只是个引子，<strong>希望能通过这次主持引起大家对亲密关系的重视，学习爱的能力，恋爱能力不是天赋，也是需要不断学习的</strong></li>
</ol>
<span id="more"></span>

<h3 id="爱飞的鸟瞎扯"><a href="#爱飞的鸟瞎扯" class="headerlink" title="爱飞的鸟瞎扯"></a>爱飞的鸟瞎扯</h3><p>我认为，亲密关系的学习可以分为两部分，一部分是自我，一部分是与人相处。首先你要会爱自己，懂得情绪管理，没有严重性格缺陷的人，然后才是与人沟通、共情。</p>
<p>妄图通过恋爱来修复缺爱的自己，抑郁的自己，等等，都是非常不可取的。希望大家别走我老路。</p>
<p>亲密关系的学习和其他自我管理、效率提升类书籍类似，刚接触会觉得豁然开朗，后期会觉得自己懂了很多，所有书讲的都类似，但却用不出来，容易看了就忘。所以还是需要多多实践体会理解，无论怎么说，在这上面认真花些功夫，总是对以后的恋爱和家人相处有非常大的帮助的。</p>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><p>不少书有同名书，请认准作者</p>
<h3 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h3><h4 id="依恋类型"><a href="#依恋类型" class="headerlink" title="依恋类型"></a>依恋类型</h4><p><a href="https://zhuanlan.zhihu.com/p/334508634">教你判断4种依恋类型（附专业心理测试） - 知乎</a></p>
<p>这篇文章必看（里面的视频可不看），起码快速浏览一下，我希望大家知道以下几点：</p>
<ol>
<li>明白自己的依恋类型是什么</li>
<li>如果自己的依恋类型是不安全的，怎么面对怎么调整？</li>
<li>可以的话以后分析下对方的依恋类型如何，该如何与其相处？</li>
</ol>
<p>书籍推荐：</p>
<ul>
<li><p>如果你是安全型依恋，性格没啥问题，不用看书，浏览浏览相关文章就好</p>
</li>
<li><p>如果你觉得自己逃脱不了原生家庭给自己带来阴影，推荐你阅读 《原生家庭-如何修补自己的性格缺陷》，作者苏珊·福沃德。所有性格有些许缺陷的人都可以阅读此书，因为依恋类型几乎就是完全由小时候的环境决定的，「你都没体验过正常的爱，不知道正常的爱是什么样的，又怎么可能懂得如何爱别人呢？」</p>
</li>
<li><p>如果你是焦虑型依恋，推荐你阅读 《执迷-如何正常地爱与被爱》，作者苏珊·福沃德</p>
</li>
<li><p>如果你容易在爱情中受伤，推荐你阅读《依恋·为什么我们爱得如此卑微》，作者还是刚刚那人！</p>
</li>
<li><p>（抱歉我对回避型依恋接触较少，或许可以尝试《原生家庭》、《把不安当朋友》。知乎有非常多的文章都很不错的，纯看文章我觉得完全ok）</p>
</li>
</ul>
<h4 id="情绪管理能力"><a href="#情绪管理能力" class="headerlink" title="情绪管理能力"></a>情绪管理能力</h4><p>自我情绪稳定非常重要，书目暂无，可自行寻找相关文章和书籍，网络上的资源很多。有个ABC理论我觉得很不错，可以去搜下，主要还是改变自己的认知，即事情已经发生不可改变，但是我们可以改变对事情的看法，从而改变结果（情绪、做法）。上期的《勇气》主题其实也与此类有所交叉。</p>
<p>（写太多了，先这样吧）</p>
<h3 id="相处-偏概念类"><a href="#相处-偏概念类" class="headerlink" title="相处-偏概念类"></a>相处-偏概念类</h3><h4 id="《亲密关系》-罗兰米勒"><a href="#《亲密关系》-罗兰米勒" class="headerlink" title="《亲密关系》- 罗兰米勒"></a>《亲密关系》- 罗兰米勒</h4><blockquote>
<p>这本书的优点在于，以系统的、完整的、科学的方式，解答了人们对爱情的困惑，对亲密关系有了较为全面的认知。</p>
</blockquote>
<p>可以把这本书理解为亲密关系的 「百科全书」、「字典」，「教科书」，相对难读。</p>
<p>推荐阅读：<a href="https://www.zhihu.com/question/40077665/answer/1111617699">如何评价《亲密关系》罗兰.米勒著这本书？ - 知乎</a></p>
<p>上述链接不仅有对这本书评价，更有些总结，不一定看这本书，但这个知乎文章值得一看，可以带你走进亲密关系的新世界。</p>
<h4 id="《爱的艺术》-弗洛姆"><a href="#《爱的艺术》-弗洛姆" class="headerlink" title="《爱的艺术》- 弗洛姆"></a>《爱的艺术》- 弗洛姆</h4><blockquote>
<p>这是一本深入探讨爱的意义与爱的理论实践的书，但如作者在前言中所说，这并非一本传授所谓爱的艺术秘诀的书。</p>
</blockquote>
<p>这本书讲的相对偏哲学一点，爱的范围更广阔些</p>
<h3 id="相处-偏实践类"><a href="#相处-偏实践类" class="headerlink" title="相处-偏实践类"></a>相处-偏实践类</h3><h4 id="《爱的五种能力》-赵永久"><a href="#《爱的五种能力》-赵永久" class="headerlink" title="《爱的五种能力》 - 赵永久"></a>《爱的五种能力》 - 赵永久</h4><p>这本书偏向长期情感关系维持，你可以学习到爱的五种实实在在的重要能力：情绪管理、述情、共情、允许、影响。书中的每一个能力都值得去深究去学习，都有相关的专门讲该能力的书，大家可以自行扩展。本书例子多，容易理解。</p>
<h4 id="《爱的五种语言》-盖瑞·查普曼"><a href="#《爱的五种语言》-盖瑞·查普曼" class="headerlink" title="《爱的五种语言》 - 盖瑞·查普曼"></a>《爱的五种语言》 - 盖瑞·查普曼</h4><blockquote>
<p>经常会看到这样的说法：“如果Ta真的爱我，Ta就该很贴心，知道我想要什么，会努力满足我的需要……”</p>
<p>似乎做不到这些，就成了不够爱甚至不爱的实锤铁证。</p>
<p>故事里也经常会描绘完美的恋人，仿佛有读心术一样地满足对方的一切需求，在对方最需要Ta的时候以最恰当的方式出现，说出最贴心的台词。</p>
<p>然而现实世界中，<strong>我们对于爱的需求，真的可以像故事里那样，被心上人恰好满足吗？</strong></p>
<p><strong>我们对于爱的表达，又真的能恰好是对方想要的吗？</strong></p>
<h2 id="也许我们都没能听懂对方"><a href="#也许我们都没能听懂对方" class="headerlink" title="也许我们都没能听懂对方"></a><strong>也许我们都没能听懂对方</strong></h2><p>无论是已经身处亲密关系中，还是恋人未满，我们都很容易忽略一件事：<strong>爱的表达方式不止一种。</strong></p>
</blockquote>
<p>详细书籍推荐可阅读此文章，<a href="https://zhuanlan.zhihu.com/p/26707739">爱有5种语言， 你在说哪种？ - 知乎</a></p>
<h4 id="《非暴力沟通》-马歇尔·卢森堡"><a href="#《非暴力沟通》-马歇尔·卢森堡" class="headerlink" title="《非暴力沟通》- 马歇尔·卢森堡"></a>《非暴力沟通》- 马歇尔·卢森堡</h4><p>非常有名的一本讲沟通的书，这本书不是专讲亲密关系的，但是沟通却是亲密关系中极其重要的一环。对亲密关系不感兴趣的同学也可以看看这本，人的本质是社会关系的总和，到哪里都是要交流沟通的。读完后想精进的话，可以继续阅读《沟通的艺术》</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>《伯恩斯焦虑自助疗法》、《伯恩斯新情绪疗法》，治疗焦虑和抑郁的</p>
<p>《爱的博弈：建议信任、避免背叛与不忠》，讲爱情的信任的</p>
<p>《共情的力量：情商高的人，如何抚慰受伤的灵魂》，这是我看的一本专门讲共情的书，个人觉得值得一读。城市、谦逊、接纳、宽容、感恩、信念、希望、宽恕</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>阅历有限，列举的书目可能无法满足所有人的需求，欢迎大家一起挖掘有价值的书，一起讨论！本次共读我觉得唤起大家对恋爱能力的重视，远比内容本身重要。</p>
<div align="right">爱飞的鸟</div>

<div align="right">2021年5月3日</div>]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>亲密关系</tag>
      </tags>
  </entry>
  <entry>
    <title>关于读闲书以及做笔记的思考</title>
    <url>/2021/03/%E5%85%B3%E4%BA%8E%E8%AF%BB%E9%97%B2%E4%B9%A6%E4%BB%A5%E5%8F%8A%E5%81%9A%E7%AC%94%E8%AE%B0%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="阅读方式"><a href="#阅读方式" class="headerlink" title="阅读方式"></a>阅读方式</h2><p>目前我读书有以下几种方式：「精读」、「笔记阅读」、「略读」、「选读」</p>
<span id="more"></span>

<p>「精读」即完整地看完整本书，有时候会做笔记，如果不做笔记会对重点句子划线</p>
<p>「笔记阅读」是我自己取的名字，就是看别人的读书笔记起到阅读的效果，我最喜欢的是看幕布精选的读书笔记，因为幕布的读书笔记多是大纲式的，阅读笔记可以快速掌握书的脉络与大部分内容；其次是知乎、简书。笔记阅读的优点是能节省很多时间，缺点就是不容易理解或理解有偏差，并且因为不是读的原文，无法对某些精彩的点建立深刻的印象，容易读完就忘。所以现在，笔记阅读对我来说，主要有以下三种用法：略读书籍、挑选书籍、读后复习。</p>
<p>「略读」、「选读」我觉得差不多，「略」得多了、快了，可不就成「选读」了，索性放一块了。灵感来源于很久以前看的某篇文章，当时作者称之为「猜书」，大概是看了目录后，猜测文章的内容是什么，然后快速翻阅，如果确实和自己想的一样，那么就可以直接跳过。比如《执迷》这本书，我在知乎上看了不少文章，以及亲身经历，对「焦虑型依恋」的成因和表现十分清楚，所以只读了这本书的方法论部分。</p>
<h2 id="记笔记"><a href="#记笔记" class="headerlink" title="记笔记"></a>记笔记</h2><p>讲一下这些天看书的经验，对我来说，是否应该记笔记。</p>
<p>原来我是很讨厌记笔记的，一个是麻烦且浪费时间，另一个是会破坏读书的体验。我喜欢用 Kindle 读书，再用个电脑记笔记，太怪了，还伤眼。所以一直都是用 Kindle 直接划线。但是弊端来了，划线或者说摘抄，我后面根本不会去看，而且划线比较随性，没有自己的思考，所以决定还是边看边记，或者第二遍再做笔记。</p>
<p>我不做「大纲式笔记」，只是按章节，把每个章节触动到我的，觉得重要的句子，用自己的话写下来，而不是简单摘抄。这样一来，我必须边读书边思考，边想着作者这章在表达什么，哪些又是真正能为我所用的，哪些我并不赞同或者与我无关的能直接跳过，哪怕后面记的笔记我也不看，但是这个过程会让我养成思考的习惯。</p>
<p>这些章节性的总结摘要，组成了我的读书笔记的「读书笔记」部分。看完整本书，我会结合前面记录的句子，总结出整本书对我的启发，这个启发特指以后我在生活中真正能想起来并为我所用的，即「转化」部分。</p>
<p>来个小总结，「读书笔记」部分是为了以写促思，「转化」部分是为了把「阅读量」转化为「吸收量」、「改变量」。 </p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>怦然心动的人生整理魔法-读书笔记</title>
    <url>/2021/03/%E6%80%A6%E7%84%B6%E5%BF%83%E5%8A%A8%E7%9A%84%E4%BA%BA%E7%94%9F%E6%95%B4%E7%90%86%E9%AD%94%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="书籍基本信息"><a href="#书籍基本信息" class="headerlink" title="书籍基本信息"></a>书籍基本信息</h2><p>作者：近藤麻离惠<br>标签：个人管理、生活管理</p>
<span id="more"></span>

<h2 id="阅读方式与进度"><a href="#阅读方式与进度" class="headerlink" title="阅读方式与进度"></a>阅读方式与进度</h2><ul>
<li>理论篇<ul>
<li>精读（理论篇前两章）：阅毕 2021年3月14日</li>
<li>略读+笔记阅读（理论篇剩余）：阅毕 2021年3月14日</li>
</ul>
</li>
<li>实践篇<ul>
<li>待读</li>
</ul>
</li>
</ul>
<h2 id="读书笔记"><a href="#读书笔记" class="headerlink" title="读书笔记"></a>读书笔记</h2><h3 id="怦然心动的人生整理魔法"><a href="#怦然心动的人生整理魔法" class="headerlink" title="怦然心动的人生整理魔法"></a>怦然心动的人生整理魔法</h3><h4 id="第1章：为什么再怎么整理都整理不好"><a href="#第1章：为什么再怎么整理都整理不好" class="headerlink" title="第1章：为什么再怎么整理都整理不好"></a>第1章：为什么再怎么整理都整理不好</h4><ul>
<li><p>几乎所有人都是按自己的方式整理，平时人们并不重视整理的学习</p>
</li>
<li><p>如果<strong>一口气整理完</strong>，房间就会一口气变得整齐，但很多时候你以为的一口气整理完其实真正只整理了一半，所以会反弹</p>
</li>
<li><p>作者信奉的不是「培养每天整理一点的习惯」，而是「通过一次性整理，使意识发生戏剧性的变化」</p>
</li>
<li><blockquote>
<p>如果能进行一次性正确的整理，就能立刻看到效果，而且能长久保持整理后的整洁状态，只要亲身体验这个过程，我想任何人都会在心底里深切感到不能再让房间回复杂乱了</p>
</blockquote>
</li>
<li><p>整理时该做的，大致只有两件事，<strong>一是确定物品的弃留</strong>，<strong>二是设定物品放置的位置</strong></p>
</li>
<li><p>要迅速整理完毕，然后面对自己真正应该面对的问题。比如考试前很多人喜欢整理，但这只是因为想通过整理来缓解焦虑，反而浪费了大量时间</p>
</li>
<li><p>收纳不能真正解决整理的问题，治标不治本。所以整理要从丢弃无用物品开始</p>
</li>
<li><p>不能按场所整理，要<strong>按物品类别整理</strong></p>
</li>
<li><p>整理与个性无关（原文是：按个性改变整理方法，毫无意义）其实不会整理者一共有三种类型</p>
<ul>
<li>不愿丢弃型</li>
<li>不能把物品放回原位型</li>
<li>既不愿丢又不能放回原位型 </li>
</ul>
</li>
<li><p>整理是节庆，不需要每天做，就是一次把它做完</p>
</li>
</ul>
<h4 id="第2章：只留下让你怦然心动的，其他统统「丢掉」"><a href="#第2章：只留下让你怦然心动的，其他统统「丢掉」" class="headerlink" title="第2章：只留下让你怦然心动的，其他统统「丢掉」"></a>第2章：只留下让你怦然心动的，其他统统「丢掉」</h4><ul>
<li>短时间整理完成，给意识冲击</li>
<li><strong>==整理的顺序==一定要严格执行，丢完前绝对不行进行收纳</strong><ol>
<li>丢弃物品</li>
<li>设置收纳场所（设定物品放置的位置）</li>
</ol>
</li>
<li>丢东西前，先思考「理想的生活」，即整理的目的，要达到什么效果，一定要清晰</li>
<li><strong>选择物品的标准：「触碰时有心动感吗」</strong>，选择的是留下什么，而不是把注意力放在要扔掉什么</li>
<li>把同类的物品集中起来，进行要一次性判断。我们必须正确掌握自己现在到底拥有多少物品</li>
<li>刚开始丢弃的时候从难度低的物品开始，把难度大的如纪念品留到最后</li>
<li>尽量不要让父母看到自己丢弃的东西，他们有可能会因为觉得可惜自己拿去，但大多数时候他们并不会用，反而成了负担</li>
<li>如何让家人学会整理：自己做好丢弃，做好榜样</li>
</ul>
<h4 id="第3章：按「物品类别」整理，竟如此顺利！"><a href="#第3章：按「物品类别」整理，竟如此顺利！" class="headerlink" title="第3章：按「物品类别」整理，竟如此顺利！"></a>第3章：按「物品类别」整理，竟如此顺利！</h4><p>看完前两章，我发现其实作者已经把她的思想强调过很多次了，这时去知乎看了几篇阅读笔记，大家写的东西都是相似的，并且和我自己归纳的也一致（前文加粗的部分即作者的主要思想），那么这本书的整体脉络思路我其实已经把握了，所以剩下的部分直接改为略读。</p>
<ul>
<li>这章触动我的点，或者说学到的新知识是：叠衣服的时候，叠成小长方形，比我平时折的更小些，然后竖着放，好处是衣服之间不会互相压着，取衣服的时候不会乱，同时不容易有褶皱（作者认为衣服折叠的褶皱是衣服互相挤压，这点等我实践后再看）观点是很打动我的，尤其是我其实挺会叠衣服，也是分类放置，但是整理完之后，过段时间就又会乱了，因为衣服叠放移动几件衣服就容易乱，可以尝试竖着放。但是学校的衣柜是比较高的，如果竖着放空间利用率会很低，而作者讲述的是用抽屉收纳竖着放的衣服，所以到底适不适合还要看具体操作。（第四章作者有了补充，用空鞋盒，不错）</li>
</ul>
<h4 id="第4章：让人闪闪发亮的「心动收纳课」"><a href="#第4章：让人闪闪发亮的「心动收纳课」" class="headerlink" title="第4章：让人闪闪发亮的「心动收纳课」"></a>第4章：让人闪闪发亮的「心动收纳课」</h4><ul>
<li>每个物品都要设定固定的位置，用完放回原处（我以前也会大致设定物品的位置，连左右口袋装什么我都会设定好，所以我几乎没有找完左口袋又摸右口袋的情况。但对于桌面与柜子的整理，物品类别太多，许多东西我是没有归类的，正是这些临时性的没有严格归类的小物品，让我的空间越来越乱）</li>
</ul>
<h4 id="第5章：让人生发生喜剧性变化的整理魔法"><a href="#第5章：让人生发生喜剧性变化的整理魔法" class="headerlink" title="第5章：让人生发生喜剧性变化的整理魔法"></a>第5章：让人生发生喜剧性变化的整理魔法</h4><p>引用知乎「<a href="https://zhuanlan.zhihu.com/p/57909732">余小满</a>」的话：</p>
<blockquote>
<p>我们整理的不仅仅是物品与环境，而是自己的内心。过好当下，不念过去，不畏将来。</p>
</blockquote>
<h4 id="结束语：整理魔法，让你的每一天闪耀光芒"><a href="#结束语：整理魔法，让你的每一天闪耀光芒" class="headerlink" title="结束语：整理魔法，让你的每一天闪耀光芒"></a>结束语：整理魔法，让你的每一天闪耀光芒</h4><h3 id="怦然心动的人生整理魔法：实践解惑篇"><a href="#怦然心动的人生整理魔法：实践解惑篇" class="headerlink" title="怦然心动的人生整理魔法：实践解惑篇"></a>怦然心动的人生整理魔法：实践解惑篇</h3><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><ul>
<li>（突然萌生了一个很有意思的想法，我在读这本书的时候，其实也是在做「整理」，丢弃大部分内容，只留下让我心动的）</li>
<li>必须一次性整理完</li>
<li>整理前好好想象一下整理之后期待的样子</li>
<li><strong>==整理的顺序==一定要严格执行，丢完前绝对不行进行收纳</strong><ol>
<li>丢弃物品<ol>
<li>选择的是留下来的物品，不是把重点放在要丢什么</li>
<li>判断是否要丢的标准是，触摸，是否心动</li>
</ol>
</li>
<li>设置收纳场所（设定物品放置的位置）<ol>
<li>按类别整理，把同类的聚在一起，有利于看清自己拥有的东西的现状，不要按地点</li>
<li>用完了及时放回</li>
</ol>
</li>
</ol>
</li>
<li>衣服建议竖着摆</li>
<li>在整理的时候，我们能知道自己真正喜欢什么在意什么，还能在整理中悟得不要迷恋过去、更重要的是未来。</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title>解决hexo博客leancloud访问量永远是1的错误</title>
    <url>/2021/03/%E8%A7%A3%E5%86%B3hexo%E5%8D%9A%E5%AE%A2leancloud%E8%AE%BF%E9%97%AE%E9%87%8F%E6%B0%B8%E8%BF%9C%E6%98%AF1%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="错误定位"><a href="#错误定位" class="headerlink" title="错误定位"></a>错误定位</h2><p>定位到错误：这条请求标红，并且含有 <code>Counter</code>，我猜是 <code>leancloud</code> 修改访问量的接口</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210313162321026.png" alt="image-20210313162321026"></p>
<p>返回是这样的：<img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210313162351656.png" alt="image-20210313162351656"></p>
<p>应该是<code>Couter</code>类的权限设置问题，默认设置是创建所有人可创建，但访问者没有写（更新）的权限，导致阅读量一直是1。</p>
<span id="more"></span>

<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><p>进入<code>leancloud</code>控制台，【存储】-【结构化数据】-【Counter】，删除 Class</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210313162937093.png" alt="image-20210313162937093"></p>
<p>再创建一个 <code>Counter</code> Class，注意下面选【无限制】</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210313163038465.png" alt="image-20210313163038465"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.ouyanting.com/archives/2018/12/ebe3ded2.html">Forbidden writing by object’s ACL. - Yanting Ou</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔20200915</title>
    <url>/2021/03/%E9%9A%8F%E7%AC%9420200915/</url>
    <content><![CDATA[<p>刷题做笔记时，无意间看到去年9月份写的随笔，隐去了别人的姓名，顺手传上来吧</p>
<span id="more"></span>

<p>这段时间似乎在想很多东西，也不知想明白没有，决定记一些下来。  </p>
<p>大概分为以下几个方面，得与失，时间，自身缺点。  </p>
<p>这一年又可以算上我的低谷，似乎我总觉得自己处在低谷，容易一蹶不振。从去年9月到现在，做的最大的两个决定便是，一，打小挑比赛，二，考研。当初的想法是利用比赛来贴金，也是因为之前被别人加绩点羡慕到了，当了队长，一年的时间断断续续精力都花在上面，但是没获得省级奖励。现在看来也觉得后悔，觉得十分不值，貌似又是一个“错误”的决定，我发现一直以来我是个很自卑的人，觉得很多东西都做不了，但后来发现其实当时的自己完全可以做到，或许自卑是另一种为自己开脱的借口。  </p>
<p>考研方面，也是因为自己很大的一个缺点，不喜欢定计划，统筹能力不行，没有目标，哪里来的执行，日常的具体表现，就是有时候学的很猛，有时候又完全不学，效率和状态不在线上，导致现在自己陷入了一个很尴尬的境地。</p>
<p>但人不能总流于表面的，不能一直活在过去的阴影中的，不能活在无限的错误中的。比赛方面，既然有失，而且我也不是废人，那么必有得，所以得是什么呢？主要分为两个方面：  </p>
<ol>
<li>自我硬实力提升、人际关系<ol>
<li>我一直在人际交往，或者说非计算机专业方面有很大的欠缺，最近甚至觉得自己有些孤僻了。</li>
<li>打比赛的过程中，涉及到任务分配、积极性调动、以及人与人之间的潜规则，学到了不少。</li>
<li>人际关系方面，看到了某某的“八面玲珑”，一个看起来很水，不喜欢弄专业功课的人，做项目打比赛似乎也吊儿郎当，但是就是认识很多人，无论用什么方式，从最开始的每天和我说晚安，到后面有空就聊一点，用很简单的方式就稳固了人际关系，是我需要学习的。*(2021年3月12日晚，后记：以我现在的待人角度来说，他身上其实也我很多欣赏的地方，作为一个管理专业的人，本身就是要投身到各种社团参与，活动举办上来，我认为他在自己的领域已经很强了。并且如果他是看似轻松，那么一定也有背后的辛苦；如果他确实很轻松，他们他会更厉害，天生就是管理的料)*</li>
</ol>
</li>
<li>反思<ol>
<li>想把这一年的经历，当作自己新的一轮蜕变，如果说上次是爱情观、生活观上的改变，这次是对自我管理（时间、性格认识）的彻底深入以及社会化的努力尝试。</li>
<li>痛则思变，如果不改变，以后只会更痛。现在形式很严峻，但算不上最坏，在总结了之前的错误之后，不应继续沉迷在对过去的错误的悔恨中，而是想着怎么在当前的自我条件、外部环境下，让未来更漂亮。</li>
</ol>
</li>
</ol>
<p>或许，现在问我如何成功，我的答案是“目标+方法+时间”，没有目标，就不会有努力的动力，没有时间管理能力，没有实践，怎么出成果，而方法又是决定效率的关键，在大家都拼时间的情况下，效率也很重要。根据某某分享的一些中国经济的事实，似乎钱的规则也是有许多普通人所想不到的点的，另辟蹊径也是办法，不过那需要更广阔的知识和眼界做支撑。今年的我，在这三个方面，似乎都没做到，所以是失败的，明年的我，一定是成功的。今年没明确的目标，没有阶段任务，导致无动力，时间上无论是客观的比赛原因，还是自己懒，贪玩，都是没花时间学习。最后因为想逃避，所以屏蔽了很多考研信息，这又是方法的失败。光分析是没用的，认识的最终目的，还是获得正确的方法论，是应用到实践上面，后面的三个多月，相信自己，不负自己，不负相亲相爱之人。</p>
<p><em>2021年3月12日晚，后记：</em></p>
<p><em>看完这篇文章，我发现自己当时确实在慢慢想着改变，但当时或许更多的是停留在思想层面，落实的不多。扪心自问，现在虽然我也没有落实太多自己的想法，但我这几个月是真真切切感受到痛苦了的，改变的痛苦。由内而外的改变是痛苦的，只有感受到了痛苦，才是真的改变了。</em></p>
<p><em>昨天躺在床上，想着，以前喜欢蜕变这个词，现在并不喜欢，我认为，蜕变并不能正确得描述改变的过程与体验，人的改变哪里是一瞬间。改变是这样的，它就像，你拿着个锤子，知道这块骨头有问题，解决的办法只能是把它敲碎，把它重塑成你希望的样子好的样子，看你有没有勇气去触碰它，仅仅意识到是没有用的。直到现在，我承认，我也只是敲碎了一部分骨头，有不少骨头迟迟不忍动，还有些正在愈合的阵痛期，甚至还有些愈合后，再次敲碎。不过，我也很享受新长出的骨骼所给我带来的一切。</em></p>
<p><em>最后，回答一下半年前的话，「后面的三个多月，相信自己，不负自己，不负相亲相爱之人」，我敢肯定，我做到了（此处没有应该两字，以前的我总喜欢用「逃避」来逃避什么）。</em></p>
<p><em>又写多了，害，是弄完了开题报告和开题答辩PPT的兴奋。现在三座大山，暂时只剩复试和新苗啦！</em></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>hexo新建菜单并添加文章</title>
    <url>/2021/03/hexo%E6%96%B0%E5%BB%BA%E8%8F%9C%E5%8D%95%E5%B9%B6%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h2 id="两种不同效果对比"><a href="#两种不同效果对比" class="headerlink" title="两种不同效果对比"></a>两种不同效果对比</h2><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>本文章使用的是 <code>next</code> 主题，其他主题类似。</p>
<p>以添加「读书笔记」菜单为例，以下是最终效果</p>
<span id="more"></span>

<h3 id="效果一"><a href="#效果一" class="headerlink" title="效果一"></a>效果一</h3><p>菜单点开，里面有相关分类的文章，可一直往该页面增加文章，但不能在该界面加其余陈述。<strong>相当于给某个特定分类在菜单栏建立了个快捷方式</strong>。</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210308234647999.png" alt="image-20210308234647999"></p>
<h3 id="效果二"><a href="#效果二" class="headerlink" title="效果二"></a>效果二</h3><p>菜单点开后，只有一篇文章，不能链接其他文章。<strong>可以类比「关于」界面</strong></p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210309001205793.png" alt="image-20210309001205793"></p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="1-（效果一、二都要做）新建一个名为-readNotes-的页面，命令如下"><a href="#1-（效果一、二都要做）新建一个名为-readNotes-的页面，命令如下" class="headerlink" title="1. （效果一、二都要做）新建一个名为 readNotes 的页面，命令如下"></a>1. （效果一、二都要做）新建一个名为 <code>readNotes</code> 的页面，命令如下</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page readNotes</span><br></pre></td></tr></table></figure>

<p>取名可随意，哪怕写中文的 <code>读书笔记</code> 也是可以的，看个人习惯。</p>
<p>后续：我后面还是直接取了中文的 <code>读书笔记</code> 的名字，一个是省事，一个是翻译文件只会翻译菜单的 <code>readNotes</code>，可以看到两个效果图中的右侧的分类和标题都还是 <code>readNotes</code> 没被翻译。</p>
<p>这时候你会发现 <code>/source/</code> 文件夹下多了个 <code>readNotes</code> 文件夹，里面有个 <code>index.md</code>。</p>
<p>效果二中，<code>index.md</code> 类似 <code>next</code> 内置的「关于」等界面，里面可以写内容，效果一编辑此文件无效。</p>
<h3 id="2-（一、二）在主题配置中开启菜单"><a href="#2-（一、二）在主题配置中开启菜单" class="headerlink" title="2. （一、二）在主题配置中开启菜单"></a>2. （一、二）在主题配置中开启菜单</h3><h4 id="效果一-1"><a href="#效果一-1" class="headerlink" title="效果一"></a>效果一</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">	<span class="attr">readNotes:</span> <span class="string">/categories/readNotes/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-bookyml</span></span><br></pre></td></tr></table></figure>

<h4 id="效果二-1"><a href="#效果二-1" class="headerlink" title="效果二"></a>效果二</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">	<span class="attr">readNotes:</span> <span class="string">/readNotes/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-book</span></span><br></pre></td></tr></table></figure>

<h4 id="图标问题（一、二）"><a href="#图标问题（一、二）" class="headerlink" title="图标问题（一、二）"></a>图标问题（一、二）</h4><p><code>fa-book</code> 是图标的简称，<code>next</code> 用的是 Font Awesome 的图标</p>
<p>在官网 <a href="https://fontawesome.dashgame.com/">Font Awesome，一套绝佳的图标字体库和CSS框架</a> 中搜索喜欢的图标，点击复制即可</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210309001915721.png" alt="image-20210309001915721"></p>
<h3 id="3-修改语言文件，将-readNotes-翻译为「读书笔记」"><a href="#3-修改语言文件，将-readNotes-翻译为「读书笔记」" class="headerlink" title="3. 修改语言文件，将 readNotes 翻译为「读书笔记」"></a>3. 修改语言文件，将 readNotes 翻译为「读书笔记」</h3><p>原本取的就是中文名的可以跳过这步。</p>
<p>自从 NexT-7.3.0 开始，官方推荐采用数据文件将配置与主题分离，这样我们可以在不修改主题源码的同时完成选项配置、自定义布局、自定义样式，便于后续 NexT 版本更新。</p>
<p>我们原来是通过配置主题下的 <code>languages</code> 目录中的 <code>zh-CN.yml</code> 文件来对菜单等进行中文翻译的，现在我们可以通过在 <code>hexo/source/_data/</code> 下新建数据文件 <code>languages.yml</code>，并全文配置如下：（注意注释部分）</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">zh-CN:</span>	<span class="comment">#看这里，把下面的内容（即next主题的原zh-CN文件，向右缩进</span></span><br><span class="line">		<span class="comment"># 然后加个标头zh-CN，使用zh-Hans的同理</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">简体中文</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">archive:</span> <span class="string">归档</span></span><br><span class="line">    <span class="attr">category:</span> <span class="string">分类</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="string">标签</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="attr">menu:</span></span><br><span class="line">    <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">    <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">    <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">    <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">    <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">    <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br><span class="line">    <span class="attr">commonweal:</span> <span class="string">公益</span> <span class="number">404</span></span><br><span class="line">    <span class="attr">readNotes:</span> <span class="string">读书笔记</span>	<span class="comment">#在这里添加</span></span><br><span class="line">  <span class="attr">sidebar:</span></span><br><span class="line">    <span class="attr">overview:</span> <span class="string">站点概览</span></span><br><span class="line">    <span class="attr">toc:</span> <span class="string">文章目录</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">  <span class="comment">#（以下省略，不要直接复制本代码，先缩进，再加zh-Hans或zh-CN标头，再加readNotes: 读书笔记）</span></span><br></pre></td></tr></table></figure>

<p>关于配置文件与主题分离，强烈建议阅读这篇文章：</p>
<p><a href="https://tding.top/archives/2bd6d82.html">Hexo-NexT 版本更新记录 | 小丁的个人博客</a></p>
<h3 id="4-（仅一）如果在新建文章时进行归类"><a href="#4-（仅一）如果在新建文章时进行归类" class="headerlink" title="4. （仅一）如果在新建文章时进行归类"></a>4. （仅一）如果在新建文章时进行归类</h3><p>写文章时，头部加个 <code>readNotes</code> 分类就行，以下是 next 主题的方式</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">(title,</span> <span class="string">date等其余头部信息已省略)</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">readNotes</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>先在这个分类下写一篇文章，再 <code>hexo s</code>，否则会报错。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><p>参考了小丁的关于 <code>next</code> 主题的数据文件部分，主要是 <code>languages.yml</code> <a href="https://tding.top/archives/2bd6d82.html">Hexo-NexT 版本更新记录 | 小丁的个人博客</a></p>
</li>
<li><p>参考了本篇博客的大部分内容 <a href="https://blog.csdn.net/weixin_30312557/article/details/98233523?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-6.control">hexo添加新菜单并实现新菜单的文章归类_weixin_30312557的博客-CSDN博客</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>CS</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hdoj刷题六(java)：2050-2059</title>
    <url>/2021/03/hdoj%E5%88%B7%E9%A2%98%E5%85%AD(java)%EF%BC%9A2050-2059/</url>
    <content><![CDATA[<p>向同学了解到第11页后半段的题才有意思，于是先从 P2050 开始刷了，同时为了保持索引的有序性，名字也先取「六」了，「三四五」先空缺着。</p>
<span id="more"></span>

<h3 id="Problem-2050-折线分割平面"><a href="#Problem-2050-折线分割平面" class="headerlink" title="Problem - 2050 折线分割平面"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2050">Problem - 2050 折线分割平面</a></h3><h3 id="Problem-2051-Bitset"><a href="#Problem-2051-Bitset" class="headerlink" title="Problem - 2051 Bitset"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2051">Problem - 2051 Bitset</a></h3><p>这题为典型的10进制转二进制，不断取余2再除2就行。但是这样的数位是反的，所以我有两种思路将其弄正：</p>
<ul>
<li>一种是弄个数组反向输出，数组大小为log2(N+1)向上取整，向上取整有点东西的，一开始我表达式就写错了。并且学到了 java 的 log2n方式：</li>
</ul>
<blockquote>
<p>在java中求log2N，首先要弄明白一个初中学到的公式log2N=logeN/loge2,logeN代表以e为底的N的对数,loge2代表以e为底的2的对数.<br>在java.lang.math类中的log(double a)代表以e为底的a的对数,因此log2N在Java中的表示为:<br>log((double)N)/log((double)2)</p>
</blockquote>
<p>所以实际计算数组长度的时候代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> len = (<span class="keyword">int</span>) Math.ceil((Math.log((<span class="keyword">double</span>)(num+<span class="number">1</span>))/Math.log((<span class="keyword">double</span>)<span class="number">2</span>)));</span><br></pre></td></tr></table></figure>

<p>下面是完整代码：一遍过！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/12 23:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2051</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            ten2Two(num);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ten2Two</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) Math.ceil((Math.log((<span class="keyword">double</span>)(num+<span class="number">1</span>))/Math.log((<span class="keyword">double</span>)<span class="number">2</span>)));</span><br><span class="line"><span class="comment">//        System.out.println(&quot;len:&quot; + len);</span></span><br><span class="line">        <span class="keyword">int</span>[] numTwo = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            numTwo[i] = num % <span class="number">2</span>;</span><br><span class="line">            num /= <span class="number">2</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=len-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            System.out.print(numTwo[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种我想试试递归输出，先计算再输出，递归可能不占优，但是一直对递归的思想理解不透彻，想试试</li>
</ul>
<p>没想到一下子就写出来了！果然凌晨是敲代码的最佳时机！奖励自己一片面包，长胖！</p>
<p>思路是这样的，既然最先算出来的最后输出，那么其实和树的后序遍历很像：先递归下去，返回到根节点的时候再输出，即，先把 num/2 传下去算着，等算完了再把 num%2 输出，递归退出判断是什么呢？当然是和上面那个方法的 while 退出判断一样啦，为0就退出。</p>
<p>以下是递归实现的函数部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">ten2Two2</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ten2Two2(num/<span class="number">2</span>);</span><br><span class="line">            System.out.print(num%<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Problem-2052-Picture"><a href="#Problem-2052-Picture" class="headerlink" title="Problem - 2052 Picture"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2052">Problem - 2052 Picture</a></h3><p>画图狂喜，想起了以前大一的时候写打字游戏和贪食蛇。</p>
<p>这题主要是细节问题，注意 <code>n&gt;0</code>，<code>m&gt;0</code>，其中 <code>n</code> 是宽度，即列数。以及每两个长方形之间有个空行。</p>
<p>因为输出太多，我嫌 <code>java</code> 的输出太长，抖了个机灵重新封装了一下哈哈哈，体验倍增！</p>
<p>（目前这题一直提示表达错误）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/14 19:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2052</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            n = sc.nextInt();</span><br><span class="line">            m = sc.nextInt();</span><br><span class="line">            <span class="comment">//打印首行</span></span><br><span class="line">            pr(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                pr(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pr(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            pr(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="comment">//打印中间部分</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;m; j++)&#123;</span><br><span class="line">                pr(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;n; k++)&#123;</span><br><span class="line">                    pr(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                pr(<span class="string">&quot;|\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印尾行，和首行一样</span></span><br><span class="line">            pr(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">                pr(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pr(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">            <span class="comment">//注意每两个长方形之间有个空白行</span></span><br><span class="line">            pr(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pr</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        System.out.print(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Problem-2053-Switch-Game"><a href="#Problem-2053-Switch-Game" class="headerlink" title="Problem - 2053 Switch Game"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2053">Problem - 2053 Switch Game</a></h3><p>判断第 n 个灯的状态，只要看 1 - n 中，有几个数能整除就行，用取余操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/14 20:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2053</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            <span class="keyword">boolean</span> open = <span class="keyword">false</span>;</span><br><span class="line">            n = sc.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (n%i == <span class="number">0</span>)&#123;</span><br><span class="line">                    open = !open;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(open ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Problem-2054-A-B"><a href="#Problem-2054-A-B" class="headerlink" title="Problem - 2054 A == B ?"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2054">Problem - 2054 A == B ?</a></h3><p>本来以为是水题，后来觉得没这么简单，然后用 <code>Double</code>，<code>euqal</code>函数，还是错。后面百度了一下，他们是用字符串，把后面的<code>.00000000</code>去掉，所以我猜，测试样例应该特别大。奇怪，我用<code>new BigDecimal(sc.next())</code> 测试，还是通不过。下面是字符串解法：</p>
<p>还是有很多细节的，比如要考虑是否为小数，遍历顺序，以及是否要变小数为整数，详见代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/14 20:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2054</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String m, n;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            m = sc.next();</span><br><span class="line">            n = sc.next();</span><br><span class="line">            m = trim(m);</span><br><span class="line">            n = trim(n);</span><br><span class="line">            <span class="keyword">if</span> (m.equals(n))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">trim</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果没有小数点就直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!s.contains(<span class="string">&quot;.&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下面是有小数点的情况，从右往左，记录第一个非0的位置</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j) != <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//还要考虑小数点也要抹去的情况</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(j) == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(<span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s.substring(<span class="number">0</span>, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Problem-2055-An-easy-problem"><a href="#Problem-2055-An-easy-problem" class="headerlink" title="Problem - 2055 An easy problem"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2055">Problem - 2055 An easy problem</a></h3><p>这题对我来说最难的反而是输入，<code>nextInt()</code> 后需要多写一个 <code>nextLine()</code> 把回车吃掉，我猜 <code>nextInt()</code> 没有处理回车，然后 <code>nextLine()</code> 在第一个回车处终止，导致第一行数字后面的换行会消耗一个 <code>nextLine()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/14 21:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2055</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        <span class="comment">//需要把回车读了</span></span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="comment">//java没有nextCharacter()，只能以字符串的形式读取</span></span><br><span class="line">            String inputStr = sc.nextLine();</span><br><span class="line">            <span class="comment">//x只有一位</span></span><br><span class="line">            <span class="keyword">char</span> x = inputStr.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//x是从下标为2到len-1部分</span></span><br><span class="line">            <span class="keyword">int</span> y = Integer.parseInt(inputStr.substring(<span class="number">2</span>, inputStr.length()));</span><br><span class="line">            System.out.println(y + f(x));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">char</span> ch)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch&gt;=<span class="string">&#x27;a&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -(ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了可阅读性，还是用else if吧</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ch&gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; ch&lt;=<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ch - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Problem-2056-Rectangles"><a href="#Problem-2056-Rectangles" class="headerlink" title="Problem - 2056 Rectangles"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2056">Problem - 2056 Rectangles</a></h3><h3 id="Problem-2057-A-B-Again"><a href="#Problem-2057-A-B-Again" class="headerlink" title="Problem - 2057 A + B Again"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2057">Problem - 2057 A + B Again</a></h3><h3 id="Problem-2058-The-sum-problem"><a href="#Problem-2058-The-sum-problem" class="headerlink" title="Problem - 2058 The sum problem"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2058">Problem - 2058 The sum problem</a></h3><h3 id="Problem-2059-龟兔赛跑"><a href="#Problem-2059-龟兔赛跑" class="headerlink" title="Problem - 2059 龟兔赛跑"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2059">Problem - 2059 龟兔赛跑</a></h3>]]></content>
      <categories>
        <category>CS</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>hdoj刷题二(java)：2010-2019</title>
    <url>/2021/03/hdoj%E5%88%B7%E9%A2%98%E4%BA%8C(java)%EF%BC%9A2010-2019/</url>
    <content><![CDATA[<h2 id="题目、分析与代码"><a href="#题目、分析与代码" class="headerlink" title="题目、分析与代码"></a>题目、分析与代码</h2><h3 id="Problem-2010-水仙花数"><a href="#Problem-2010-水仙花数" class="headerlink" title="Problem - 2010 水仙花数"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2010">Problem - 2010 水仙花数</a></h3><p>再跳说不过去了，这里写一下， 个人觉得这里最难的是数位的拆分。有两种方法：</p>
<ol>
<li>读取成数字，然后先取余，再除10，循环</li>
<li>读取成字符串，获取子串，再用 <code>parseInt()</code></li>
</ol>
<span id="more"></span>

<p>我的骨子里还是个 <code>C语言</code> 程序员，且第一种明显高效，这里用第一种</p>
<p>还有对于输出的处理，最后一个输出后没有空格，采取的方式见代码。</p>
<p>以及我犯的一个错误，判断是否为水仙花数，多次除10后，原数已经变成0，需要一个新变量记录原来的数，即那个变量 <code>n</code>。还有一种解决方式是，把 <code>sum</code> 等于 <code>num</code>，然后一个个减去，最后判断 <code>sum</code> 是不是0就行。</p>
<p>这题我 <code>Presentation Error</code> 好多次，太难受了！上面还有一点忘了，就是一组结束后，要加换行！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/7 22:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2010</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min, max;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            min = sc.nextInt();</span><br><span class="line">            max = sc.nextInt();</span><br><span class="line">            <span class="keyword">int</span> i=min;</span><br><span class="line">            <span class="comment">// 为了实现最后一个数字后没空格，这里把空格加到数字的前面</span></span><br><span class="line">            <span class="comment">// 所以第一个数字要特殊处理</span></span><br><span class="line">            <span class="keyword">for</span> (; i&lt;=max; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (isNarcissusNum(i))&#123;</span><br><span class="line">                    System.out.print(i);</span><br><span class="line">                    <span class="comment">// 这里i不自增的话和输出两遍第一个数</span></span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 i&gt;max 说明一个数字也没</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; max)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (; i&lt;=max; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (isNarcissusNum(i))&#123;</span><br><span class="line">                    System.out.print(<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这里记得换行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isNarcissusNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, n =num;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> digit = n % <span class="number">10</span>;</span><br><span class="line">            sum += digit * digit * digit;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-2011-多项式求和"><a href="#Problem-2011-多项式求和" class="headerlink" title="Problem - 2011 多项式求和"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2011">Problem - 2011 多项式求和</a></h3><p>这题就弄个 <code>for</code> 循环吧，应该能过</p>
<h3 id="Problem-2012-素数判定"><a href="#Problem-2012-素数判定" class="headerlink" title="Problem - 2012 素数判定"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2012">Problem - 2012 素数判定</a></h3><p>这题很经典，LeetCode 刷过，用<strong>厄拉多塞筛法</strong>，直接当时的笔记拿过来。</p>
<p>解法一：暴力法（超时），不详细展开</p>
<p>解法二：暴力法优化，循环上限开个根号，循环步长改为2，即排除偶数</p>
<p>解法三：<strong>厄拉多塞筛法</strong>，顺序遍历（从2开始），每取得一个数，那么它的倍数就一定不是素数，筛去，以此类推，<a href="https://leetcode-cn.com/problems/count-primes/solution/ji-shu-zhi-shu-bao-li-fa-ji-you-hua-shai-fa-ji-you/">题解原文</a></p>
<p>题解代码：（哈哈哈这代码好像是当时复制的别人的 <code>C++</code>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始默认所有数为质数</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">signs</span><span class="params">(n, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (signs[i]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + i; j &lt; n; j += i) &#123;</span><br><span class="line">                <span class="comment">//排除不是质数的数</span></span><br><span class="line">                signs[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续，要结合题目把这题写出来。</p>
<p>这题还学到了一个<code>List</code>初始化的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建长度为n的 Boolean List，初始化为 true</span></span><br><span class="line">List&lt;Boolean&gt; signs = <span class="keyword">new</span> ArrayList&lt;&gt;(Collections.nCopies(n, <span class="keyword">true</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="Problem-2013-蟠桃记"><a href="#Problem-2013-蟠桃记" class="headerlink" title="Problem - 2013 蟠桃记"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2013">Problem - 2013 蟠桃记</a></h3><p>数学题，每次 + 1 再 *2</p>
<h3 id="Problem-2014-青年歌手大奖赛-评委会打分"><a href="#Problem-2014-青年歌手大奖赛-评委会打分" class="headerlink" title="Problem - 2014 青年歌手大奖赛_评委会打分"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2014">Problem - 2014 青年歌手大奖赛_评委会打分</a></h3><p>使用 <code>sort</code> 函数排序</p>
<h3 id="Problem-2015-偶数求和"><a href="#Problem-2015-偶数求和" class="headerlink" title="Problem - 2015 偶数求和"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2015">Problem - 2015 偶数求和</a></h3><p>挨个加就好，不过先用 <code>n / m * m</code> 这个操作算出前面 n 的倍数，剩下的几个再根据数量算平均值</p>
<h3 id="Problem-2016-数据的交换输出"><a href="#Problem-2016-数据的交换输出" class="headerlink" title="Problem - 2016 数据的交换输出"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2016">Problem - 2016 数据的交换输出</a></h3><p>遍历就完事~</p>
<h3 id="Problem-2017-字符串统计"><a href="#Problem-2017-字符串统计" class="headerlink" title="Problem - 2017 字符串统计"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2017">Problem - 2017 字符串统计</a></h3><p>判断是否是数字可以这样，两种方法，我还是喜欢第一种偏C的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;a1&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&#x27;0&#x27;</span>&lt;=s.charAt(<span class="number">1</span>) &amp;&amp; s.charAt(<span class="number">1</span>)&lt;=<span class="string">&#x27;9&#x27;</span>);   <span class="comment">//输出true</span></span><br><span class="line">System.out.println(Character.isDigit(s.charAt(<span class="number">1</span>))); <span class="comment">//输出true</span></span><br></pre></td></tr></table></figure>

<h3 id="Problem-2018-母牛的故事"><a href="#Problem-2018-母牛的故事" class="headerlink" title="Problem - 2018 母牛的故事"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2018">Problem - 2018 母牛的故事</a></h3><p>用一个数组递推即可</p>
<h3 id="Problem-2019-数列有序"><a href="#Problem-2019-数列有序" class="headerlink" title="Problem - 2019 数列有序!"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2019">Problem - 2019 数列有序!</a></h3><p>插入排序，注意以下几个细节：</p>
<ol>
<li>哨兵</li>
<li>输出格式<ol>
<li>最后一个数字后没有空格</li>
<li>记得每组输出后换行</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/8 19:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2019</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m, n;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            n = sc.nextInt();</span><br><span class="line">            m = sc.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">                nums[i] = sc.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            nums[<span class="number">0</span>] = m;</span><br><span class="line">            <span class="keyword">int</span> j = n;</span><br><span class="line">            <span class="keyword">for</span> (; nums[j] &gt; nums [<span class="number">0</span>]; j--)&#123;</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//注意这里是j+1</span></span><br><span class="line">            nums[j+<span class="number">1</span>] = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;n+<span class="number">1</span>; k++)&#123;</span><br><span class="line">                System.out.print(nums[k] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//最后一个数字后没有空格，以及记得换行</span></span><br><span class="line">            System.out.println(nums[n+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>hdoj刷题一(java)：2000-2009</title>
    <url>/2021/03/hdoj%E5%88%B7%E9%A2%98%E4%B8%80(java)%EF%BC%9A2000-2009/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>本次刷题主要是针对复试，刷 hdoj 第11页的题，以前用的是 <code>C++</code>，最近一年用 <code>Java</code> 做项目多，也是想着以后靠 <code>Java</code> 吃饭，所以换用 <code>Java</code>。寒假在 <code>LeetCode</code> 刷了一些题，所以最近的刷题主要是习惯用 <code>Java</code> 做输入输出以及用 <code>Java</code> 写算法题（多留意常用 <code>api</code>，背下来，考试手写）</p>
<p>下面是找到的一篇输入输出教程，足够应付了：</p>
<p><a href="https://blog.csdn.net/shijiebei2009/article/details/17305223">ACM之Java输入输出_以家为家，以乡为乡，以国为国，以天下为天下-CSDN博客_acm java输入输出</a></p>
<span id="more"></span>

<h2 id="题目与代码"><a href="#题目与代码" class="headerlink" title="题目与代码"></a>题目与代码</h2><h3 id="Problem-2000-ASCII码排序"><a href="#Problem-2000-ASCII码排序" class="headerlink" title="Problem - 2000 ASCII码排序"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2000">Problem - 2000 ASCII码排序</a></h3><p>主要有两点：</p>
<ol>
<li>读取字符的时候，先用 <code>next()</code> 读取，再转成字符串数组，或者用 <code>charAt()</code></li>
<li><code>System.out.println(s[0] + &quot; &quot;+ s[1] + &quot; &quot; + s[2]);</code> 这里的 <code>&quot; &quot;</code>，不能改成 <code>&#39; &#39;</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/7 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2000</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            s = sc.next().toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] &gt; s[<span class="number">1</span>])&#123;</span><br><span class="line">                swap(s, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">0</span>] &gt; s[<span class="number">2</span>])&#123;</span><br><span class="line">                swap(s, <span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] &gt; s[<span class="number">2</span>])&#123;</span><br><span class="line">                swap(s, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(s[<span class="number">0</span>] + <span class="string">&quot; &quot;</span>+ s[<span class="number">1</span>] + <span class="string">&quot; &quot;</span> + s[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> temp = s[i];</span><br><span class="line">        s[i] = s[j];</span><br><span class="line">        s[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Problem-2001-计算两点间的距离"><a href="#Problem-2001-计算两点间的距离" class="headerlink" title="Problem - 2001 计算两点间的距离"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2001">Problem - 2001 计算两点间的距离</a></h3><p>这是我今年在 <code>hdoj</code>上做的第一道题（有不少以前用 <code>C</code> 刷过），主要练了以下几点：</p>
<ol>
<li><p><code>Java</code> 输入</p>
<ol>
<li>输入流建立 <code>Scanner sc = new Scanner(System.in)</code> </li>
<li>判断输入流是否结束，用 <code>sc.hasNext()</code> </li>
<li>读入一个字符串用 <code>sc.next()</code>，数字用 <code>sc.nextInt()</code>，<code>sc.nextDouble</code>，以此类推</li>
</ol>
</li>
<li><p><code>Double</code> 的格式化输出，摘抄上面博客的一段内容</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里0指一位数字，#指除0以外的数字(如果是0，则不显示),四舍五入.</span></span><br><span class="line">DecimalFormat fd = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.00#&quot;</span>);</span><br><span class="line">DecimalFormat gd = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0.000&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;x =&quot;</span> + fd.format(x));</span><br><span class="line">System.out.println(<span class="string">&quot;x =&quot;</span> + gd.format(x));</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    NumberFormat formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;000000&quot;</span>);</span><br><span class="line">    String s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -001235</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;##&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -1235</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    s = formatter.format(<span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;##00&quot;</span>);</span><br><span class="line">    s = formatter.format(<span class="number">0</span>); <span class="comment">// 00</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;.00&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">.567</span>); <span class="comment">// -.57</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;0.00&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">.567</span>); <span class="comment">// -0.57</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.#&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -1234.6</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.######&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -1234.567</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;.######&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -1234.567</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.000000&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -1234.567000</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#,###,###&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -1,235</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    s = formatter.format(-<span class="number">1234567.890</span>); <span class="comment">// -1,234,568</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">// The ; symbol is used to specify an alternate pattern for negative values</span></span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#;(#) &quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// (1235)</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">// The &#x27; symbol is used to quote literal symbols</span></span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot; &#x27;# &#x27;# &quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// -#1235</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot; &#x27;abc &#x27;# &quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">1234.567</span>); <span class="comment">// - abc 1235</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">    formatter = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.##%&quot;</span>);</span><br><span class="line">    s = formatter.format(-<span class="number">12.5678987</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>hdoj</code> 的提交规范</p>
<ol>
<li>注意判断输入流结束</li>
<li>不能带有包名</li>
<li>将类名改为 <code>Main</code>，这里是要将 <code>P2001</code> 改为 <code>Main</code></li>
</ol>
</li>
<li><p>细节问题，一开始没看到说输入是「实数」，被样例迷惑了</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/7 15:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2001</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] coor = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>];    <span class="comment">//坐标，分别为x1, y1, x2, y2</span></span><br><span class="line">        Arrays.fill(coor, <span class="number">0</span>);</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.00&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">                coor[i] = sc.nextDouble();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算距离，因为是平方，所以谁减谁问题不大</span></span><br><span class="line">            <span class="keyword">double</span> dis = Math.sqrt( (coor[<span class="number">0</span>]-coor[<span class="number">2</span>])*(coor[<span class="number">0</span>]-coor[<span class="number">2</span>]) + (coor[<span class="number">1</span>]-coor[<span class="number">3</span>])*(coor[<span class="number">1</span>]-coor[<span class="number">3</span>]));</span><br><span class="line">            System.out.println(df.format(dis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Problem-2002-计算球体积"><a href="#Problem-2002-计算球体积" class="headerlink" title="Problem - 2002 计算球体积"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2002">Problem - 2002 计算球体积</a></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/7 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2002</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.1415927</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> r;</span><br><span class="line">        <span class="keyword">double</span> k = <span class="number">4.0</span>/<span class="number">3</span> * PI;  <span class="comment">//4/3 * pi作为一个常数提前算出来应该能快点</span></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            r = sc.nextDouble();</span><br><span class="line">            DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">&quot;#.000&quot;</span>);</span><br><span class="line">            System.out.println(df.format(k * r * r * r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Problem-2003-求绝对值"><a href="#Problem-2003-求绝对值" class="headerlink" title="Problem - 2003 求绝对值"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2003">Problem - 2003 求绝对值</a></h3><p>侮辱智商，跳过吧。两种做法：</p>
<ol>
<li><code>Math.abs()</code></li>
<li><code>num = num &gt; 0 ? num : -num</code></li>
</ol>
<h3 id="Problem-2004"><a href="#Problem-2004" class="headerlink" title="Problem - 2004"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2004">Problem - 2004</a></h3><p>纯 <code>if</code> 语句</p>
<h3 id="Problem-2005-第几天？"><a href="#Problem-2005-第几天？" class="headerlink" title="Problem - 2005 第几天？"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2005">Problem - 2005 第几天？</a></h3><p>以几下几个难点：</p>
<ol>
<li>日期的处理，因为我对日期函数不熟悉，用原始的方式，读入字符串，然后 <code>split</code> 一下，再 <code>Integer.parseInt</code></li>
<li>闰年判断</li>
<li>计算第几天<ol>
<li><strong>利用不带 break 的 switch 累计天数,注意月份要倒着写</strong></li>
<li>11月的话累计第10月，并继续往下累计9，8,，7，6，5，4，3，2，1月</li>
<li>这个方法还是大一的时候我的C语言程序设计老师郑老师教我的，也是我的编程启蒙老师，教我我很多</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lhp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/3/7 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">P2005</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String dateStr;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNext())&#123;</span><br><span class="line">            dateStr = sc.next();</span><br><span class="line">            String[] dateArray = dateStr.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> year = Integer.parseInt(dateArray[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> month = Integer.parseInt(dateArray[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> day = Integer.parseInt(dateArray[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//利用不带 break 的 switch 累计天数,注意月份要倒着写</span></span><br><span class="line">            <span class="comment">//2月的话累计1月的，3月累计1月2月的</span></span><br><span class="line">            <span class="keyword">switch</span> (month)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">12</span>:result += <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">11</span>:result += <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">10</span>:result += <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">9</span>:result += <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">8</span>:result += <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">7</span>:result += <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">6</span>:result += <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:result += <span class="number">30</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:result += <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:result += (<span class="number">28</span> + (isLeapYear(year) ? <span class="number">1</span> : <span class="number">0</span>)); <span class="comment">//处理闰年</span></span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>: result += <span class="number">31</span>;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result += day;</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeapYear</span><span class="params">(<span class="keyword">int</span> year)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year %<span class="number">100</span> != <span class="number">0</span> ||year % <span class="number">400</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Problem-2006-求奇数的乘积"><a href="#Problem-2006-求奇数的乘积" class="headerlink" title="Problem - 2006 求奇数的乘积"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2006">Problem - 2006 求奇数的乘积</a></h3><p>侮辱智商，跳过。只是输入稍微有点麻烦，先用 <code>hasNext()</code> 判断是否有新行，并读取数字个数 <code>n</code>，然后再用个循环读取就行</p>
<h3 id="Problem-2007-平方和与立方和"><a href="#Problem-2007-平方和与立方和" class="headerlink" title="Problem - 2007 平方和与立方和"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2007">Problem - 2007 平方和与立方和</a></h3><p>同侮辱智商，跳过</p>
<h3 id="Problem-2008-数值统计"><a href="#Problem-2008-数值统计" class="headerlink" title="Problem - 2008 数值统计"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2008">Problem - 2008 数值统计</a></h3><p>同侮辱智商，跳过</p>
<h3 id="Problem-2009-求数列的和"><a href="#Problem-2009-求数列的和" class="headerlink" title="Problem - 2009 求数列的和"></a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2009">Problem - 2009 求数列的和</a></h3><p><code>Math.sqrt()</code> ，不需要 <code>import</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己的编程基础应该还是不错的，高中就学过一点点 <code>C++</code>，大学 <code>C语言</code> 接近满绩，算法课比较水所以最后满绩，真不是故意跳那么多，一个是这些的确是签到题，一个是事情太多了，毕业设计，复试七本书和算法，新苗，人快没了。这是我第一次这么认真写刷题笔记，以后博客也要认真坚持写下来，加油。</p>
<p>P2000，P2001，P2002，练习了输入输出，以及数字的四舍五入。</p>
<p>P2005 练了练快两个星期没刷算法的手，以及最基本的几个常用函数。</p>
<p>（顺便利用这篇文章测试一下 <code>hexo</code> 的博客， <code>markdown</code> 渲染是不是严格的，以前都是故意弄一个空行来区分段落，这次行末没加双空格也没加空格，看看格式会不会乱）</p>
<p>事实证明会自己换行，还挺智能。</p>
]]></content>
      <categories>
        <category>CS</category>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>起床小插曲</title>
    <url>/2021/03/%E8%B5%B7%E5%BA%8A%E5%B0%8F%E6%8F%92%E6%9B%B2/</url>
    <content><![CDATA[<p>今天早上有点冷，又遇到了我的减衣计划，于是乎，我与被子难舍难分了。这时候想到了一句诗：「乍暖还寒时候，最难将歇」，应景！改成最难起床就更妙了。</p>
<span id="more"></span>

<p>一边找衣服，一边吟着整首，突然吟到「雁过也，正伤心，却是旧时相识」，停住，反复琢磨了几遍。李清照想表达的意思早已忘记，我却有了自己的理解。大雁飞过，正在惆怅伤心，却发现这是旧识认识的那个大雁，一时间，竟不知是该怀着再次分别的伤心，还是再次相遇的欣喜了。</p>
<p>后记：查阅资料，百度汉语的翻译的「向南避寒的大雁已飞过去了，伤心的是却是原来的旧日相识」，这个相识指的是词人自己。但我还是更喜欢自己的理解，毕竟，翻译的人也不知道李清照怎么想的，子非鱼，安知鱼之乐？或许她和我想的还一样呢！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>为hexo-next安装侧边rss</title>
    <url>/2021/03/%E4%B8%BAhexo-next%E5%AE%89%E8%A3%85%E4%BE%A7%E8%BE%B9rss/</url>
    <content><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-在博客根目录下安装-hexo-generator-feed"><a href="#1-在博客根目录下安装-hexo-generator-feed" class="headerlink" title="1. 在博客根目录下安装 hexo-generator-feed"></a>1. 在博客根目录下安装<a href="https://github.com/hexojs/hexo-generator-feed"> hexo-generator-feed</a></h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="2-在博客根目录下的-config-yml-文件中添加以下代码"><a href="#2-在博客根目录下的-config-yml-文件中添加以下代码" class="headerlink" title="2. 在博客根目录下的 _config.yml 文件中添加以下代码"></a>2. 在博客根目录下的 <code>_config.yml</code> 文件中添加以下代码</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&quot; &quot;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">icon.png</span></span><br></pre></td></tr></table></figure>

<h3 id="3-配置博客根目录下的-config-yml-文件"><a href="#3-配置博客根目录下的-config-yml-文件" class="headerlink" title="3. 配置博客根目录下的 _config.yml 文件"></a>3. 配置博客根目录下的 <code>_config.yml</code> 文件</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">url:</span> <span class="string">自己域名</span></span><br></pre></td></tr></table></figure>

<h3 id="4-修改-Next-主题的配置文件-config-yml"><a href="#4-修改-Next-主题的配置文件-config-yml" class="headerlink" title="4. 修改 Next 主题的配置文件 _config.yml"></a>4. 修改 <code>Next</code> 主题的配置文件 <code>_config.yml</code></h3><p>首先，这里的主题配置文件最好是根目录下的 <code>_config_next.yml</code>，如果没有的话，建议把 <code>/thems/next/_config.yml</code> 文件复制到根目录下，并改名成 <code>_config_next.yml</code>。</p>
<p>不直接修改<code>/themes/next/_config.yml</code> 的好处是，当拉取新的更新时，不会因修改了<code>_config.yml</code>而发生冲突。（每个主题都是一个独立的 <code>git</code>项目）</p>
<p><code>rss</code> 有两种形式，一种是侧边栏，一种是每个文章底部都有个大大的<code>rss</code>区域，推荐侧边烂。(缩进都是两格，我这里代码可能缩进格数不对)</p>
<p>侧边栏形式：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">	<span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">rss</span></span><br></pre></td></tr></table></figure>

<p>文章底部形式：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">follow_me:</span></span><br><span class="line">	<span class="attr">RSS:</span> <span class="string">/atom.xml</span> <span class="string">||</span> <span class="string">rss</span></span><br></pre></td></tr></table></figure>

<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><p><a href="https://www.gagahappy.com/use-next-theme/">Hexo安装Next主题 Rss 侧边栏 | 漂自己的移，让别人都撞墙去吧</a></p>
<p><a href="https://suyin-blog.club/2020/2M3YWE7/">给 Hexo 中的 Next 主题添加 RSS 功能 | 苏寅 Blog</a></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+next+valine配置博客评论邮件通知（阿里云企业邮箱）</title>
    <url>/2021/03/hexo+next+valine%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E8%AF%84%E8%AE%BA%E9%82%AE%E4%BB%B6%E9%80%9A%E7%9F%A5%EF%BC%88%E9%98%BF%E9%87%8C%E4%BA%91%E4%BC%81%E4%B8%9A%E9%82%AE%E7%AE%B1%EF%BC%89/</url>
    <content><![CDATA[<h2 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h2><blockquote>
<p>不喜欢重复造轮子和复制粘贴别人的内容，这里在Valine-Admin官方教程和某博客的基础上，增加<strong>阿里云企业邮箱</strong>的配置部分，以及指出原博客中的一些错误</p>
</blockquote>
<p>某博客：<a href="https://segmentfault.com/a/1190000021474516?utm_source=tag-newest">Hexo主题使用Valine-Admin管理评论和评论提醒 - SegmentFault 思否</a></p>
<p>Valine-Admin 官方教程：<a href="https://github.com/zhaojun1998/Valine-Admin">zhaojun1998/Valine-Admin: 一个 Valine 的拓展应用，用来增强 Valine 的邮件通知。</a></p>
<span id="more"></span>

<h2 id="邮件通知部署流程"><a href="#邮件通知部署流程" class="headerlink" title="邮件通知部署流程"></a>邮件通知部署流程</h2><p>完全按上面的「某博客」来即可，下面指出博客中的一些不清晰的地方以及错误</p>
<h3 id="阿里云企业邮箱"><a href="#阿里云企业邮箱" class="headerlink" title="阿里云企业邮箱"></a>阿里云企业邮箱</h3><p>用管理员账号，一般为 <code>postmaster@域名</code>，依次点击【组织与用户】-【员工账号管理】-【新建账号】</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210306152129677.png" alt="image-20210306152129677"></p>
<p>基本信息填写略，注意下图红框部分勾选</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210306152223749.png" alt="image-20210306152223749"></p>
<p>值得注意的是，我搜了半天，甚至登录了员工邮箱，都没找到 <code>SMTP</code> 授权码。经尝试，<strong>授权码就是上图中给员工邮箱分配的密码</strong>。</p>
<p>也就是说，<code>leancloud</code> 中要填写的环境变量有这些（如果用阿里云企业邮箱）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SITE_NAME : 网站名称。</span><br><span class="line">SITE_URL : 网站地址, 最后不要加 &#x2F; 。</span><br><span class="line">SMTP_USER : 填写创建的员工邮箱地址（SMTP 服务用户名，一般为邮箱地址。）</span><br><span class="line">SMTP_PASS : 阿里云为创建员工邮箱时分配的密码（SMTP 密码，一般为授权码，而不是邮箱的登陆密码，请自行查询对应邮件服务商的获取方式）</span><br><span class="line">SENDER_NAME : 寄件人名称。</span><br><span class="line">TO_EMAIL：填写自己的收件邮箱，所以的评论都会发给这个邮箱</span><br><span class="line">TEMPLATE_NAME：设置提醒邮件的主题，目前内置了两款主题，分别为 default 与 rainbow。默认为 default</span><br><span class="line">SMTP_HOST : 阿里云为：smtp.mxhichina.com（邮件服务提供商 SMTP 地址，如 qq : smtp.qq.com，此项需要自行查询或询问其服务商。）</span><br><span class="line">SMTP_PORT : 阿里云为：25 （邮件服务提供商 SMTP 端口, 此项需要自行查询或询问其服务商。）</span><br></pre></td></tr></table></figure>

<h3 id="定时任务自动唤醒"><a href="#定时任务自动唤醒" class="headerlink" title="定时任务自动唤醒"></a>定时任务自动唤醒</h3><p>还有个环境变量是 <code>ADMIN_URL</code>，是原博客中设置定时任务自动唤醒要用到的，设置方法如下：</p>
<p>进入应用，依次点击：【云引擎】-【web】-【设置】，下拉（其实和环境变量在同一页），找到【云引擎域名】，绑定一下，下图红框内的文字即为 <code>ADMIN_URL</code> 项应填入的值</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210306153102967.png" alt="image-20210306153102967"></p>
<h3 id="原博客捡漏定时任务错误"><a href="#原博客捡漏定时任务错误" class="headerlink" title="原博客捡漏定时任务错误"></a>原博客捡漏定时任务错误</h3><p>博客中关于捡漏定时任务的描述中，截图和给出的代码不一致，（截图是正确的），这里我给出正确代码以供复制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 8 * * ?</span><br></pre></td></tr></table></figure>



<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210306153610390.png" alt="image-20210306153610390"></p>
<h3 id="next主题配置文件修改"><a href="#next主题配置文件修改" class="headerlink" title="next主题配置文件修改"></a>next主题配置文件修改</h3><p>还有一点博客没提到，原作者应该是默认大家已经会开启评论但是没设置邮件通知。</p>
<p>应该这样修改，<code>enable</code> 和 <code>notify</code> 改为 <code>true</code>，以及 <code>appid</code> 与 <code>appkey</code> 填完整</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210306153258422.png" alt="image-20210306153258422"></p>
]]></content>
      <categories>
        <category>CS</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo5.0+安装报错总结</title>
    <url>/2021/03/hexo5.0+%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="部署与备份小总结"><a href="#部署与备份小总结" class="headerlink" title="部署与备份小总结"></a>部署与备份小总结</h2><p>经过我三次的 <code>hexo</code> 部署经验，现在也算是摸清了它的逻辑，这次没照搬网上的教程，自己摸索出了如何通过设置分支来部署备份。</p>
<span id="more"></span>

<p>首先明确两点，<code>github</code> 展示的页面，不由自己掌管，也不用自己 <code>git push</code> 全部交由 <code>hexo g -d</code> 这个命令来完成，它会在 <code>/public</code> 文件夹中生成要部署的静态页面，然后复制到 <code>/.deploy_git</code> 文件夹中，再全部覆盖推到我们在 <code>/_config.yml</code>中设置的 分支，若设置的是 <code>master</code>，则文件内容是这样的：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p>我们要做的，是设置一个备份分支，如 <code>hexo</code> 分支，并在 <code>github</code> 中将其设置成默认分支，然后手动推到远程，<code>master</code> 和 <code>hexo</code>这两个分支没有关联，我们也只要维护 <code>hexo</code>分支来备份自己的文件。而 <code>master</code>分支下的静态文件的提交，由 <code>hexo g -d</code>来完成（是的这部分我说了两遍）</p>
<p>有一点需要注意，在仓库界面，如果你建立的第一个分支不是静态文件所在的那个分支，要手动改回 <code>master</code>，即 <code>hexo</code> 分支。（一般情况最先建立的都是主分支，即静态文件分支，不用进行这个操作）</p>
<p><img src="https://tcualhp-notes.oss-cn-hangzhou.aliyuncs.com/img/image-20210305214426331.png" alt="image-20210305214426331"></p>
<p>我的操作流程是这样的：</p>
<ol>
<li>先在本地把整个博客都搭好了，文件夹名字随意</li>
<li>在远程仓库建立 <code>用户名.github.io</code> 仓库，注意 <code>readme</code> 和 <code>.gitignore</code> 文件都不要</li>
<li>在本地博客目录下， <code>git init</code>，然后 <code>git remote add origin git@github.com:用户名/用户名.github.io.git</code> 与远程仓库建立联系</li>
<li>然后再把本地文件提交，推上去，再检出 <code>hexo</code> 分支，推上去，将 <code>hexo</code> 分支设置为默认分支</li>
<li>后面需要写文章的时候，用 <code>hexo new &quot;文件名&quot;</code></li>
<li>部署和备份直接运行我去年写的脚本，将脚本复制到博客根目录下，<code>git bash</code> 键入：<code>sh auto_deploy.sh &quot;github提交的commit&quot;</code> 即可完成部署+备份</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切回hexo, 以防万一</span></span><br><span class="line">git checkout hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交本地的</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;$1&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交到远程</span></span><br><span class="line">git push origin hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"> 到页面发布分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清理原html</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成，部署</span></span><br><span class="line">hexo g -d</span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回原文件分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git checkout hexo</span>		</span><br></pre></td></tr></table></figure>



<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>写到这里，下面的链接早已不局限于安装部署了，各种杂七杂八的关于自建 <code>hexo</code> 的链接都有收录</p>
<p><code>hexo</code> 官方文档：<a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p>
<ul>
<li><code>hexo</code> 中 <code>_posts</code> 文件夹分类：</li>
<li><a href="https://blog.csdn.net/maosidiaoxian/article/details/85220394">如何在Hexo中对文章md文件分类_一个码农的博客-CSDN博客</a></li>
<li><a href="https://www.dazhuanlan.com/2020/03/28/5e7e34ca352b3/">如何对hexo中的文章进行分类管理 | 大专栏</a></li>
<li>添加看板娘：<a href="https://blog.csdn.net/qq_36239569/article/details/104104894">Hexo添加Live2D看板娘最新教程_enchanted的博客-CSDN博客</a></li>
<li><a href="https://tang.su/2020/09/upgrade-hexo-to-5-0/#more">https://tang.su/2020/09/upgrade-hexo-to-5-0/#more</a>)</li>
<li><a href="http://www.yangyong.xyz/2018/01/03/add-hexo-next-post-views/">Hexo NexT 主题优化：显示文章阅读次数 | 九月枫林</a></li>
<li><a href="https://blog.csdn.net/zhu_1997/article/details/87554975">hexo博客next主题添加 评论功能_Mumu’s Blogs-CSDN博客</a></li>
<li><a href="https://github.com/zhaojun1998/Valine-Admin">zhaojun1998/Valine-Admin: 一个 Valine 的拓展应用，用来增强 Valine 的邮件通知。</a></li>
<li><a href="https://blog.csdn.net/weixin_43438052/article/details/106617739?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&spm=1001.2101.3001.4242">[转]Hexo主题使用Valine-Admin管理评论和评论提醒_MelodyJerry-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/lingfeian/article/details/100030808?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=1328603.27235.16150118713713009&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">阿里企业邮箱POP\SMTP\IMAP地址和端口信息_凌飞安-CSDN博客_阿里邮箱pop服务器</a></li>
<li><a href="https://lanlan2017.github.io/blog/242f5d55/">Hexo NexT 7谷歌收录 必应收录 百度收录 | 蓝蓝博客</a></li>
<li><a href="https://www.jianshu.com/p/a94422c0dc48/">Hexo博客：十一、文章置顶 - 简书</a></li>
<li><a href="https://www.gagahappy.com/use-next-theme/">Hexo安装Next主题 Rss 侧边栏 | 漂自己的移，让别人都撞墙去吧</a></li>
<li><a href="https://suyin-blog.club/2020/2M3YWE7/">给 Hexo 中的 Next 主题添加 RSS 功能 | 苏寅 Blog</a></li>
<li><a href="https://suyin-blog.club/2020/EBJEZ6/">给 Hexo Next 网站评论框配置炫酷的打字效果 | 苏寅 Blog</a></li>
<li>打字特效（一定要先看第一个链接，涉及到 next 主题配置分离思想）<ul>
<li><a href="https://tding.top/archives/2bd6d82.html">Hexo-NexT 版本更新记录 | 小丁的个人博客</a></li>
<li><a href="https://tding.top/archives/58cff12b.html">Hexo-NexT 添加打字特效、鼠标点击特效 | 小丁的个人博客</a> </li>
</ul>
</li>
<li><a href="https://cjh0613.com/20200603HexoSubmitUrlsToSearchEngine.html">hexo-submit-urls-to-search-engine 中文文档 | 峡州仙士之页</a></li>
<li>近期文章（ NexT 已经更换 Nunjucks 作为模板引擎，必须按照这里的来，旧的都显示不出）：<a href="https://tding.top/archives/2bd6d82.html">Hexo-NexT 版本更新记录 | 小丁的个人博客</a></li>
<li><a href="https://blog.garryde.com/archives/63320.html">Hexo Next阅读次数不正常、显示多个阅读次数 | 咖里De</a></li>
</ul>
<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><h3 id="报错一："><a href="#报错一：" class="headerlink" title="报错一："></a>报错一：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: YAMLException: end of the stream or a document separator is expected (1:1)</span><br><span class="line"></span><br><span class="line">   1 | &#96;&#96;&#96;</span><br><span class="line">  -----^</span><br><span class="line">      at generateError (D:\Desktop\blog\node_modules\js-yaml\lib\loader.js:183:10)asap.js:40:19)</span><br><span class="line">      at flush </span><br><span class="line">      </span><br><span class="line">      ---------------中间省略---------------------</span><br><span class="line">      (internal&#x2F;process&#x2F;task_queues.js:75:11) &#123;</span><br><span class="line">    reason: &#39;end of the stream or a document separator is expected&#39;,</span><br><span class="line">    mark: &#123;</span><br><span class="line">      name: null,</span><br><span class="line">      buffer: &#39;&#96;&#96;&#96;\n&#39;,</span><br><span class="line">      position: 0,</span><br><span class="line">      line: 0,</span><br><span class="line">      column: 0,</span><br><span class="line">      snippet: &#39; 1 | &#96;&#96;&#96;\n-----^&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#39;s wrong. Maybe you can find the solution here: %s https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;troubleshooting.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查阅资料得知，大部分情况为，<code>_config.yml</code> 文件下所有的 <code>:</code> 后，必须有空格，且只能有一个空格。于是我开始检查，利用编辑器搜索 <code>: </code>，高亮出符合内容的冒号，这样就能快速找出不符合要求的冒号。但是试了好几遍，没有找出不符合要求的，缓存清除一类的也不行。</p>
<p>在这个时候，我仔细阅读错误，可以看到，错误中指示了 「buffer:’```\n」</p>
<p>我一直认为这是乱码，没有什么指导性作用。直到后来我看别人的报错的 <code>buffer</code> 行是这样的 <code>buffer: &#39;# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html</code>。</p>
<p>也就是说，<code>buffer</code> 后的内容真是出现错误的信息！但我的报错怎么这么奇怪啊！等下，这个怎么那么像 <code>markdown</code> 的多行代码？我在哪里写了呢，于是我想到了 <code>scaffolds/post.md</code> 中我定义的模板，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">permalink: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">categories:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>因为去年的时候我部署过 <code>hexo</code>，所以这次是直接粘贴上去的，粘贴的时候， <code>typora</code> 把 <code>---</code> 转化成了 「```」，问题解决！</p>
<h3 id="报错二"><a href="#报错二" class="headerlink" title="报错二"></a>报错二</h3><p>hexo 的链接点击不跳转，变成下载文件</p>
<p><a href="https://tang.su/2020/09/upgrade-hexo-to-5-0/#more">升级Hexo到5.0 | TS’ Blog</a></p>
<h3 id="错误三"><a href="#错误三" class="headerlink" title="错误三"></a>错误三</h3><p>我发现用 <code>npm</code> 安装 <code>next</code> 很不靠谱，<code>/themes</code> 文件夹中什么都没，所以涉及到编辑js的那些操作都做不了。于是检出了个 <code>bug_fix</code> 分支，删除了 <code>.gitkeep</code> 文件，<code>git clone</code> 了 <code>next</code> 的代码。后来又发现，主题内部自带了一份 <code>_config.yml</code> 文件，而且结构和之前的那份完全不一样！！！得知，根目录下的 <code>_config.yml</code> 的优先级比主题文件夹里面的优先级高，所以把配置复制到根目录下的配置文件，并且新的配置文件中是含有 <code>valine</code> 的默认配置的，很轻松就配置好了。</p>
<h3 id="错误四"><a href="#错误四" class="headerlink" title="错误四"></a>错误四</h3><p>无法评论，需要在 <code>leancloud</code> 中【设置】-【安全中心】中设置安全域名，即自己的域名，形式为<code>https://你在cname中填写的域名</code></p>
<h3 id="错误五"><a href="#错误五" class="headerlink" title="错误五"></a>错误五</h3><p>访客显示错误，原因是域名映射的时候，<code>github</code> 给我们映射成了 <code>https</code>，但其实我是<code>http</code>，做如下设置即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">	<span class="attr">security:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>CS</category>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>人为什么而活2</title>
    <url>/2021/03/%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E6%B4%BB2/</url>
    <content><![CDATA[<p>现在是2021年3月5日，早在2019年8月4日，我就已经思考过这个话题，当时的答案是：「<strong>做你想做的，做你该做的</strong>」，现在想想这个答案未免有些泛泛而谈，没有啥意义。当时的想法是，「想做的」即为一个人喜欢做的；「该做的」是一个人的责任，我认为这构成了人活着的意义。  </p>
<p>有趣的是，在2020年7月18日，我在知乎回答了这样一个问题：「是什么让你坚持活下去（限10个字之内）？」，我的回答是，「<strong>我爱的人，爱我的人</strong>」。当时的我应该是处于心情的低谷期，每天的焦虑、自卑、抑郁、逃避充斥着我。可以看得出来，当时的我更加注重「人」的意义。或许你会觉得，当时的我，是个重情重义的人——事实确实如此，但另一方面，这短短的八个字，也体现了我的焦虑型依恋的本质，换句话说，这个时候，我已经迷失自我了：我们把这八个字做一下小学时常考的「缩句」，那么我的回答就成了「（别）人，（别）人」，<strong>给出这个答案时候的我，根本不是为自己而活着</strong>，换句话说，我看不到自己活着的意义，心中对于「我」的概念已经很微弱了。  </p>
<span id="more"></span>

<p>人活着是要有「自我稳定性」的，包括情绪稳定、拥有取悦自己的能力，拥有一个人生活的能力等等。是很奇怪，一个人越是无法一个人活着，就越难遇到与其结伴的人；一个人越是自己能活得很好，自信乐观，优秀，越是能感染到其他人。  </p>
<p>所以，我选择了后者。</p>
<p>我曾在「声昔」发表过一个心情，「如何毁了一个人，夺去除了生命以外对TA而言最重要的东西；如何成就一个人，夺去除了生命以外对TA而言最重要的东西」。前半句很好理解，后半句我想表达什么意思呢，又为什么会想到这句话呢？前面提到，我过去的一年，迷失了自我，不是为自己而活，沉浸在负面情绪中，最终，我活着的动力，那个「爱我的人」，选择了离开。这对焦虑型依恋的我而言，就像丢了命，当时的我真的觉得活不下去了。我同时面临着自我攻击、至爱的人对我的失望放弃，还有一个多月后即将考研的压力。  </p>
<p>我认真反思过，细数了去年一年来我的缺点，有真正的缺点，也有自以为的缺点：我是个很闷的人，欢脱不起来；我是个很自卑的人，与两年前那个自信的少年截然相反；我是个不注重打扮的人，近几个月窝在寝室，随性穿衣服，加上长时间的熬夜，肤质一泻千里；我是个抑郁、焦虑的人，我看不到未来的希望，哪怕当时拥有的，我也会觉得我失去，美好的东西，我都觉得自己不配；我是个喜欢逃避的人，沉浸在那种负面情绪中，不愿走出来，或者根本走不出来；我是个社交很失败的人，以前还会努力与人接触，在有了女朋友后，把所有的社交都逐渐转向了她，这也是我逐渐无趣的一大原因，太久没好好和人说话了；我是个无法控制自己情绪的人；我是个很难与人共情的人，我无法，也可能是不愿，认真探索别人说话时的情绪，想表达的心思，无法与人感同身受；我是个做事没有计划的人，大学三年多一直在努力，但都一直在往不同的方向努力，奖学金拿了很多，比赛的奖也拿了不少，项目经历也有一些，老师和同学也都非常认可我，但我就是把牌打成了这个样子，在毕业的时候远远没有达到我期望、他人期望的水平，一直没有持续往一个方向使力，所以我想读研；我是个很怪的人，我给自己设限，我觉得自己不善于社交，我觉得自己不配享受那些高档的美食，我觉得自己做不到很多东西，我觉得很多事情只有某种类型的人才能做，而我不是；我做事太有目的性。</p>
<p>生活和自己都抛弃了我。很感激那两个星期陪伴了我的人，给我的安慰和激励。在那之后，我疯狂得进行自我救赎，我去找不同的人聊天，去接触新的圈子，去找老乡群的人，去找考研群主胡子哥，去找挽回机构（就聊了一次，毕竟还是要靠自己，有人点醒就够了——其实也是因为太贵了，价格5位数，是贫穷让我拥有了自我救赎的能力），也去找心理咨询师聊过，还有自我对话。和心理咨询师的聊天很有意思，因为当时预约的人很多，我被排到了一星期后，然而我在一星期后自愈了很多，和老师聊天的时候，全程笑着讲述我的经历，与其说是去咨询的，不如说是去演讲的。一边讲着过去的经历，一边自我分析，「我觉得这是什么什么样的心态，应该怎么样去解决」，老师也夸我分析的都对。讲到后来，老师问我，「所以你想咨询什么问题呢？」，我想了想，好像当时确实没有什么太大的问题需要咨询哈哈哈。索性就请教了个关于社交的问题，然后询问了老师的下班时间，提前几分钟结束了咨询。我觉得心里咨询师是很辛苦的，一直在认真听我的讲述，不停地记录我的情况，努力与我共情，我也有义务为她着想，我们并不是只有咨询师师咨询者的关系，也有普通朋友的关系。</p>
<p>我发现自己有个毛病是永远改不掉了，哪怕是在我经历了四个月的自我救赎，脱胎换骨后仍几乎没变——「话唠」。不同的是，如果是与人交谈，我会观察对方的反应，看是否对方愿意听；以及与人交流的时候，我现在更趋向于少说自己，而努力去识别对方的情绪，引领着对方把自己想说的说舒畅了。</p>
<p>话题拉回到自我救赎上，前面讲的是与「人」的交谈，求助，其实占比更多的，是「自我」救赎，是通过「阅读」，与自己对话。</p>
<p>最近几个月的阅读主要分为两大类：「与人」，「自我」。最初的时候，我改变的原动力是挽回她，所以在知乎上拼命搜索「挽回」，明白了许多浅层的原因，弄清了是什么导致了分手，以及挽回中的哪些错误不能犯。后来，我开始阅读「亲密关系」领域的经典书籍，去学习「为什么要去爱」、「能从爱中获得什么」、「如何去爱」，这段时间我重新审视了自己挽回的动机，去思考关于爱的深层次的内容，也正是在这段时间，我修复了自己的恋爱性格缺陷——「焦虑型依恋」，也是在这段时间，我学习了如何正确对待自己的情绪，进而控制自己的情绪，以及如何带动对方的正向情绪；学习了如何维护亲密关系；学习了如何与人沟通；学习了如何共情。后期，直到现在，我主要阅读的是关于「自我」的书籍，诸如《被讨厌的勇气》，《羞耻感》，《认知觉醒》一类的书，前两本治愈的是自己的性格，差不多根治了二十多年来的自卑心理；后面那本是关于自我提升的，因为只有自己变得优秀自律，才值得爱人与被爱，才能收获高质量的爱。当然我读的书远不止上面几本，还有知乎以及公众号上面的文章，以及我生命中的一位贵人——小黑老师，从亲密关系到社交关系，从自我管理到职场生存，都给了我实质性的帮助，启发了我很多很多。</p>
<p>人能找到自己真正喜欢的事物，真是一件很不容易却又幸福的事儿——而我找到了「读书」。读书的时候，时间是完全属于自己的，心境是完全平和的。</p>
<p>「杀不死我的，只会让我更强大」，很幸运，在绝境中，在「毁灭」与「成就」中，我选择了后者。前面那一大段我所列出的缺点，现在，有的已经成了我的优点，有的已经克服，有的正在努力的路上。</p>
<p>改变确实在一点点发生。我首先是突破了「自我设限」，如我给自己设定的「 我不擅长社交」，从而重拾了与人交流的勇气，又如我开始吃西红柿（煮的），吃洋葱，还有一次吃了室友给我捏的两个海苔饭团，这在以前，光是「海苔」和「拌饭」任何一个，都能让我的胃翻江倒海。我改变了情绪认知的方式，以前的我沉浸在被情绪控制的「爽感」中，就像毒品一般，被摧残着却又离不开。后来，我告诉自己，情绪只是身体对自己发出的信号，告诉自己身体的想法，告诉自己该怎么做了。比如焦虑的时候，身体是要告诉你该干事情了，而不是让你继续沉浸在里面。在与人交谈的时候，我能放下自己的好胜心、自卑心、嫉妒心，或许以前别人向我夸耀自己的成果的时候，我会下意识远离，一个是因为嫉妒，一个是怕引起心中的焦虑和自卑；现在我大部分时候能短暂的放下自我意识，把角色转换到对方身上，由衷地为对方高兴，并认真地赞美TA，因此我有几个朋友也比以前更「铁」了，聊天的频率、广度、深度都有增加。还有好多好多，一时间无法分享我成长的喜悦。啊对，还有最重要的一点，这两个多月，我的一个十多年的梦想实现啦——体重从90斤蹭蹭蹭窜到了100+！或许是我妈妈手艺太好的缘故，抑或是我驱散了长久以来的负面情绪的缘故。</p>
<p>2月，我开始使用一个叫「声昔」的app，认识了许多与我相似的、曾经自卑现在重获新生的人。同时，我也因为这段经历，能与很多人感同身受，温暖了很多人，给他们带来了希望。尤其是当有人发空间表达自己被温暖到了，又有人回复我：「哇，竟然有人懂我这段话的意思，太意外，太惊喜了。这是我的困惑，甚至为此焦虑，看了你说的这段话，挺有启发的，感谢（原文还有表情）」，看到这些反馈，我相信，我当时是最幸福的。我的这些举动，并不是完全无私的，帮助他们是我发自内心的乐意的，但感受到别人需要我而引发的价值感，也正是我所渴求的。后来一个叫「书籍共读讨论社」的社团，群里的气氛异常的好，在这个群中，聊天与其他地方不一样，我们都在这个氛围中努力深度思考，发的感悟反思都是一次几百个字，占满整个屏幕，无论是发话的人，还是阅读的人，都需要沉浸下来认真思考的能力。感谢这个社团，让我重新获得了深度思考的能力，让我重新能认真看完一整个文章。现在社团已经从最初的部长，蒲公英，我，发展到了满员，并且至少有四个人因为无法进群，一直在默默订阅着。声昔的社团和普通的群是不一样的，它所有的聊天都是公开的，所以大家加群，都是喜欢群内的气氛，想要加入进来。我很荣幸，能作为这样一个远离焦躁的社团的一分子，享受着大家给我带来的启迪，享受着我给大家带来的思考，享受着大家对我价值的肯定。</p>
<p>啊，我突然想到了文章的标题是：「人为什么而活2」。其实最上面的两个回答都有其正确性，但前些天看到了一篇文章，写道，「人活着没有什么意义」。是啊，我觉得人活着并不需要去追求什么所谓的意义的，<strong>「活在当下」</strong>就好，现在我这样的状态就很好。可能这是已经被说烂了的四个字，但有些东西，真的只有经历了什么，才能真正感受到它蕴含的意思。比如我以前不喜欢听歌，觉得吵闹，歌词只是歌词；现在很喜欢听歌，仿佛每句歌词，都对应着我的一段经历，对应着我的一段感悟。<strong>活在当下，是克服焦虑的关键；活在当下，亦是珍惜现在认真生活的态度；活在当下，是不盲从于结果注重过程的随和态度；活在当下，更是从一点一滴中发现快乐发现美好，保持快乐的秘诀。</strong>果真书看多了，文采也提升了，能写出这么「肉麻」的话了哈哈哈，但却都是发自肺腑的真话。</p>
<p>2021年4月18日更新：迎接全新生活全新自己，珍惜当下，欣喜于拥有，做好眼前事，趁单身的这段日子快速提升自己。</p>
]]></content>
      <categories>
        <category>think</category>
      </categories>
  </entry>
  <entry>
    <title>使用frpMgr快速搭建内网穿透</title>
    <url>/2020/04/%E4%BD%BF%E7%94%A8frpMgr%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>安装基于 <a href="https://github.com/fatedier/frp">frp</a> 的内网穿透管理面板 <a href="https://github.com/Zo3i/frpMgr">frpMgr</a> </li>
<li>利用管理面板自动安装 frp server</li>
<li>利用管理面板生成 frp client 安装语句，在待被穿透内网设备上安装</li>
<li>使用 <code>ssh</code> 访问</li>
</ol>
<span id="more"></span>

<h2 id="安装基于-frp-的内网穿透管理面板-frpMgr"><a href="#安装基于-frp-的内网穿透管理面板-frpMgr" class="headerlink" title="安装基于 frp 的内网穿透管理面板 frpMgr"></a>安装基于 <a href="https://github.com/fatedier/frp">frp</a> 的内网穿透管理面板 <a href="https://github.com/Zo3i/frpMgr">frpMgr</a></h2><ul>
<li><strong>安装</strong><ol>
<li><p><strong>安装 docker 与 docker compose</strong></p>
<ul>
<li>若无 docker : <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -O-https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;Zo3i&#x2F;OCS&#x2F;master&#x2F;docker&#x2F;docker-all2.sh | SH wget -O-</span><br></pre></td></tr></table></figure></li>
<li>若有 docker 无 docker compose : <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -L https://get.daocloud.io/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure></li>
<li>若 docker 和 docker compose都有， 跳过此步`</li>
</ul>
</li>
<li><p><strong>安装 frpMgr</strong></p>
<ul>
<li><code>https://raw.githubusercontent.com/Zo3i/frpMgr/master/web/src/main/docker/final/run.sh | SH  </code></li>
<li>约 500 M，若下载太慢可以修改 host，或者用 <a href="https://g.widora.cn/">Github代下载</a> 再传到服务器</li>
</ul>
</li>
<li><p><strong>开放防火墙 8999 端口</strong></p>
</li>
</ol>
</li>
</ul>
<h2 id="利用管理面板自动安装-frp-server"><a href="#利用管理面板自动安装-frp-server" class="headerlink" title="利用管理面板自动安装 frp server"></a>利用管理面板自动安装 frp server</h2><ul>
<li><p>访问 <code>服务器域名（ip）:8999</code>   如 <code>xx.com:8999</code>，账户密码 admin / 12345678</p>
</li>
<li><p>准备一个域名，解析 *.xxx.com （二级通配）到 frp_server 的服务器 IP</p>
</li>
<li><p>配置 frp_server (图来自 frpMgr github)</p>
<ul>
<li>服务器名称，自定义名称，不解释</li>
<li>服务器 IP：待安装 frp_server 的服务器IP</li>
<li>域名：刚刚的一级域名</li>
<li>访问端口：web 访问端口，如果配 web 访问要用到（和ssh无关），记得安全组/防火墙打开。</li>
<li>服务器用户名：服务器用户名。</li>
<li>依次点击 【保存】【远程安装】，输入服务器密码，即可看到安装成功提示</li>
<li>在服务器执行 <code>netstat -lnp|grep 7000</code> 查看服务是否成功启动</li>
</ul>
<p><img src="https://camo.githubusercontent.com/778ec45220f7dc5fae657beb12f3f21016985174/68747470733a2f2f7a78782e6f6e652f696d67732f323031392f31312f623965373761363035663330396231362e706e67"></p>
</li>
</ul>
<h2 id="利用管理面板生成-frp-client-安装语句，在待被穿透内网设备上安装"><a href="#利用管理面板生成-frp-client-安装语句，在待被穿透内网设备上安装" class="headerlink" title="利用管理面板生成 frp client 安装语句，在待被穿透内网设备上安装"></a>利用管理面板生成 frp client 安装语句，在待被穿透内网设备上安装</h2><ul>
<li>选择 <code>SSH客户端配置</code>， 点击右上角 <code>新增</code></li>
<li><img src="http://qiniu.tcualhp.cn/frp.png"></li>
<li>填写 client 配置<ul>
<li>项目名称随意</li>
<li>远程端口为之后访问外网的端口，如你之后想通过 <code>*.xx.com:8090</code> 访问内网，就填8090， 同样防火墙和安全组要打开</li>
<li>服务器选上一步添加的服务器</li>
</ul>
</li>
<li>填写成功后点击右侧 <code>linux</code>，复制安装命令，在 client 安装即可。（client 需安装 ssh, 并开放22端口）</li>
</ul>
<h2 id="使用ssl访问"><a href="#使用ssl访问" class="headerlink" title="使用ssl访问"></a>使用ssl访问</h2><ul>
<li>ip 为 frp_server域名/IP，端口为 client 配置的端口</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
  </entry>
  <entry>
    <title>一次由被推销而引发的对市场营销学的思考</title>
    <url>/2019/09/%E4%B8%80%E6%AC%A1%E7%94%B1%E8%A2%AB%E6%8E%A8%E9%94%80%E8%80%8C%E5%BC%95%E5%8F%91%E7%9A%84%E5%AF%B9%E5%B8%82%E5%9C%BA%E8%90%A5%E9%94%80%E5%AD%A6%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<h2 id="主要情景再现"><a href="#主要情景再现" class="headerlink" title="主要情景再现"></a>主要情景再现</h2><p>中午我去拿快递的时候被一个女生拦下来，背着个大大的黑色双肩包，说耽误我一分钟时间，我当时因为点了自提外卖还有再等一会都下课了人会很多快递队伍会很长就想走，她又说只有一分钟，我还是很好停下来。她说她是市场营销实习，需要连续一星期卖60盒笔(也许是一星期每天60盒)，不然就会被辞退，中间我们僵持了很久，我也动摇过，后来想了想我也是看过《人性的弱点》的，不能一直那么因为太好心被骗就还是说我真的不需要就没买</p>
<h2 id="细节梳理"><a href="#细节梳理" class="headerlink" title="细节梳理"></a>细节梳理</h2><ol>
<li><ul>
<li><strong>细节：</strong> 刚拦住我就往我手里塞两盒笔</li>
<li><strong>思考：</strong> 先下手为强，用笔困住我，后面我一直走不掉很大程度是因为我手里有笔没法推给她，同时我以为她给我笔是要送我的，以为是什么送笔推销活动之类的。同时塞给我两盒笔意思是我想让你买笔，并且数量都给你定好了，是两盒。</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 说自己市场营销的，还有说我以后也会有实习，自己以前也是我的同学一类的人，等等</li>
<li><strong>思考：</strong> 套近乎，降低你的防备，引起你的同情</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 说卖不出去就要辞退，旁边还有好几个和她一样的，她们在竞争，苦情戏</li>
<li><strong>思考：</strong> 博取同情，但是我挣扎了很久终于抵制了，我也有同情她，我看她没打伞，聊天的时候我有帮她挡太阳</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 问我大几的，我说大三，她一脸惊讶，说我长得好小</li>
<li><strong>思考：</strong> 虽然应该是真实的处于本能的夸赞，因为我从小到大都有过诸如高三被当成高一的经历，但这个的确是夸赞，给我一个人情，为的是让我买笔还她更大的人情</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 我说我计算机的不怎么用笔，给我看有个计算机的买了十多盒笔</li>
<li><strong>思考：</strong> 当时我还真信了，后来想想这个肯定是摆拍，谁会闲着没事买那么多，我以前一下子一两盒就够多了。而且她给我看很多笔，首先提高你的购买预期，然后再降低。一下子买两盒无法接受，但是如果一下子让你买十几盒，再让你买两盒，你就比较容易接受</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 我问一盒几支，一盒多少钱，她一直只说一支 2.5 元， 后来我一直追问她才说一盒十二支，一盒28（大概，具体忘了）</li>
<li><strong>思考：</strong> 一直说一支的价格是因为 2.5 这个数感觉很小，说一盒数字很大不容易接受。但是我一算就能算出一盒价钱，一般一盒笔 12 支， 一盒就要 30， 这个价格真心不便宜，再加上前段时间出了小米巨能写，这个笔性价比真不高。她犯了一个错误，一直在博取同情，却没说笔的优势或者质量，对于理性的人来说是没用的</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 后来说我买一盒，半盒，几支也行</li>
<li><strong>思考：</strong> 努力卖出去，降低你预期，再加上卖惨</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 开始说只耽误你一分钟</li>
<li><strong>思考：</strong> 只耽误我一分钟这种话对于我这种好心的人来说根本拒绝不了，我连传单都会主动去接，同时不说是卖笔，先说市场营销套近乎降低你的抗拒感，不过这个笔性价比真不高，而且一盒实在多，一两支还行</li>
</ul>
</li>
<li><ul>
<li><strong>细节：</strong> 挑人挑中了我</li>
<li><strong>思考：</strong> 当时人挺多的，但是偏偏挑了我，可能是我面善，经常遇到各种人找我推销还有加微信做任务，挑人也是一个技能</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>think</category>
      </categories>
  </entry>
  <entry>
    <title>DailyLove-日常记录小程序后端细节展现(springboot)</title>
    <url>/2019/08/DailyLove-%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%8E%E7%AB%AF%E7%BB%86%E8%8A%82%E5%B1%95%E7%8E%B0(springboot)/</url>
    <content><![CDATA[<h2 id="事件（核心）"><a href="#事件（核心）" class="headerlink" title="事件（核心）"></a>事件（核心）</h2><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h2 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h2><h2 id="组队"><a href="#组队" class="headerlink" title="组队"></a>组队</h2>]]></content>
      <categories>
        <category>CS</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>DailyLove</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装与使用IDEA部署到远程服务器</title>
    <url>/2019/08/Docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8IDEA%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Docker教程链接与自己总结，涉及教程，安装，远程配置，IDEA调用</p>
<span id="more"></span>
<blockquote>
<p>如果是想学习可以跳过这段，首先我想学docker, 查了下好像docker for windows只能win10专业版安装，所以我招了教程利用各种帖子，后来安装失败，于是我在服务器上安装，很成功。之后发现可以用IDEA一键部署到服务器，就配置了一下，因为安全组关系又浪费不少时间，后来链接成功，但打包失败，我以为本地也要装，于是又试了一下，结果一下子就好了。可是IDEA打包还是失败，还来发现了什么，重启了一下IDEA，一切就都可以了，真是吐血，本地应该不需要装Docker，直接调用远程服务器的tcp的2375接口。</p>
</blockquote>
<h2 id="Docker-教程"><a href="#Docker-教程" class="headerlink" title="Docker 教程"></a>Docker 教程</h2><ul>
<li><a href="https://yeasy.gitbooks.io/docker_practice/introduction/what.html">Docker 从入门到实践</a></li>
</ul>
<h2 id="Docker-两个版本区分"><a href="#Docker-两个版本区分" class="headerlink" title="Docker 两个版本区分"></a>Docker 两个版本区分</h2><ul>
<li><a href="https://blog.csdn.net/JENREY/article/details/84493812">dockerToolbox和docker for windows的区别</a></li>
</ul>
<h2 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h2><h3 id="Docker-for-Windows-安装"><a href="#Docker-for-Windows-安装" class="headerlink" title="Docker for Windows 安装"></a>Docker for Windows 安装</h3><ul>
<li>安装<ul>
<li><a href="https://www.cnblogs.com/samwu/p/10360943.html">Windows10家庭版安装Docker for Windows</a></li>
</ul>
</li>
<li>与虚拟机冲突解决办法<ul>
<li><a href="https://blog.csdn.net/qwsamxy/article/details/50533007">【Hyper-V】与【VirtualBox】【VMware】冲突的解决方法</a></li>
</ul>
</li>
</ul>
<h3 id="Docker-Toolbox-安装"><a href="#Docker-Toolbox-安装" class="headerlink" title="Docker Toolbox 安装"></a>Docker Toolbox 安装</h3><ul>
<li><a href="https://www.cnblogs.com/jeshy/p/10518857.html">Docker ToolBox安装</a> 无脑安装</li>
</ul>
<h3 id="Docker-Linux-安装"><a href="#Docker-Linux-安装" class="headerlink" title="Docker Linux 安装"></a>Docker Linux 安装</h3><ul>
<li>过于简单，无脑输命令就行， 第一条教程链接里面各个发行版本安装方法都有</li>
</ul>
<h2 id="IDEA-连接远程-Docker-进行部署"><a href="#IDEA-连接远程-Docker-进行部署" class="headerlink" title="IDEA 连接远程 Docker 进行部署"></a>IDEA 连接远程 Docker 进行部署</h2><h3 id="远程服务器-Docker-设置-其实就是开放2375端口"><a href="#远程服务器-Docker-设置-其实就是开放2375端口" class="headerlink" title="远程服务器 Docker 设置(其实就是开放2375端口)"></a>远程服务器 Docker 设置(其实就是开放2375端口)</h3><ul>
<li>docker 配置<ul>
<li><a href="https://blog.51cto.com/709151/2406150">Ubuntu配置方法</a></li>
<li><a href="https://blog.csdn.net/u012946310/article/details/82315302">CentOS配置方法</a></li>
</ul>
</li>
<li>服务器配置<ul>
<li>防火墙2375端口打开</li>
<li>如果是阿里云要新建安全组规则加入2375</li>
<li>如果是宝塔也要开放2375端口（注意这两个都要开放，我之前以为宝塔能直接改动阿里云的安全组就只开放了宝塔，结果一直连接超时）</li>
</ul>
</li>
</ul>
<h3 id="IDEA-设置"><a href="#IDEA-设置" class="headerlink" title="IDEA 设置"></a>IDEA 设置</h3><ul>
<li><a href="https://blog.csdn.net/forezp/article/details/70198649">docker部署spring cloud项目</a></li>
<li>记得IDEA在maven引入docker之后重启一下，不然可能会出现我之前的无法连接到 “localhost:2375” 错误</li>
</ul>
<h2 id="部分错误文档"><a href="#部分错误文档" class="headerlink" title="部分错误文档"></a>部分错误文档</h2><ul>
<li><a href="https://blog.csdn.net/ii19910410/article/details/87882917">Dockerfile ADD路径不正确问题</a></li>
<li><a href="https://blog.csdn.net/ChineseYoung/article/details/83107353">这个也不错</a></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>common</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署踩坑总结(文末有自动部署备份脚本)</title>
    <url>/2019/08/hexo%E9%83%A8%E7%BD%B2%E8%B8%A9%E5%9D%91%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>hexo安装，部署，主题，备份教程，备份为自己尝试很多次的总结，附自动部署备份脚本</p>
<span id="more"></span>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://hexo.io/zh-cn/docs/">官方教程</a> 官方教程肯定是最权威的最好的教程</li>
<li><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">使用hexo+github搭建免费个人博客详细教程</a></li>
<li><a href="https://blog.enjoytoshare.club/article/hexo-do-domain.html">域名绑定</a> 实现用自己的域名访问博客</li>
<li><a href="https://blog.csdn.net/u012195214/article/details/72721065">原文件备份</a> <code>master</code> 用于静态界面，另外新建一个分支，比如 <code>hexo</code> 用来备份原文件和配置等，<a href="#deploy_backup">点我跳转到备份详细过程防踩坑</a></li>
</ul>
<h2 id="hexo-更新"><a href="#hexo-更新" class="headerlink" title="hexo 更新"></a><code>hexo</code> 更新</h2><ul>
<li>如果以前下载过 <code>hexo</code>，记得升级，我原来用的2， 现在已经 3.9 了，被坑死</li>
</ul>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><ul>
<li> <a href="https://www.jianshu.com/p/33bc0a0a6e90">更换主题</a> 注意文章的主题地址可能过时</li>
<li><strong>next</strong> 主题已经<strong>更换地址</strong>了， 如果看的是原来的教程，<code>clone</code> 时记得<strong>更换 next 的 Github 地址</strong></li>
</ul>
<h3 id="deploy_backup"> 部署与备份</h3>
* 前期工作

<ul>
<li><p>突然发现官网写的很清楚，<a href="https://hexo.io/zh-cn/docs/deployment.html">hexo部署</a></p>
</li>
<li><p>记得在 <code>hexo-d</code> 前修改站点配置文件即 <code>_config.yml</code> 中的 <code>deploy</code> 配置， 示例， 注意替换具体仓库地址</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">&lt;repository</span> <span class="string">url&gt;</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="comment"># message: [message]</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果 <code>hexo -d</code> 报错就看 <a href="https://blog.csdn.net/weixin_36401046/article/details/52940313">这个链接</a></p>
</li>
<li><p>备份说明</p>
<ul>
<li>命令： <code>hexo d</code></li>
<li>内部实现：其实是 <code>hexo-depolyer-git</code> 将 <code>hexo-g</code> 后生成的 <code>public</code> 文件打包。所以 <code>hexo-d</code> 的时候他会把 <code>public</code> 也就是静态文件自己上传到 <code>git</code>远程仓库的 <code>master</code> 分支（ git 地址和 master 分支在站点配置文件那边要提前配置好），我们不用管。换句话说也就是如果你不备份，只需要做到这里就好了，这个命令完成的是对静态文件的上传。</li>
<li>备份：所以像前面说的，我们要备份的话，就在不影响 <code>master</code> 的情况下，新建一个分支，比如 <code>hexo</code> , 平时写文章就在 <code>hexo</code> 分支， 并且<strong>不用切换回master</strong>！！！，因为我前面讲到 master 分支也就是静态 <code>public</code> 文件的部署已经交给 <code>hexo-d</code> 全权负责了！我之前就是切回去所以错了</li>
<li>附录一（<code>.gitignore</code>）</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.<span class="built_in">log</span></span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">auto_deploy.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>附录二（<strong>自动部署备份脚本</strong>）</li>
</ul>
<blockquote>
<p><strong>使用说明：每次写完文件保存后 bash 执行 <code>sh ./auto_deploy.sh &quot;提交的message&quot;</code> 即可， 文件名自定</strong></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切回hexo, 以防万一</span></span><br><span class="line">git checkout hexo</span><br><span class="line"><span class="comment"># 提交本地的</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line"><span class="comment"># 提交到远程</span></span><br><span class="line">git push origin hexo</span><br><span class="line"><span class="comment"># 到页面发布分支</span></span><br><span class="line"><span class="comment"># 清理原静态文件</span></span><br><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 生成，部署</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>人为什么而活</title>
    <url>/2019/08/%E4%BA%BA%E4%B8%BA%E4%BB%80%E4%B9%88%E8%80%8C%E6%B4%BB/</url>
    <content><![CDATA[<p><strong>为了</strong></p>
<span id="more"></span>

<h3 id="做你想做的"><a href="#做你想做的" class="headerlink" title="做你想做的"></a><p align="center">做你想做的</p></h3><h3 id="做你该做的"><a href="#做你该做的" class="headerlink" title="做你该做的"></a><p align="center">做你该做的</p></h3>]]></content>
      <categories>
        <category>think</category>
      </categories>
  </entry>
</search>
